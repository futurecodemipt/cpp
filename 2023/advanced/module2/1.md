Графы
==============

Весь урок посвящен графам. В начале рассказываем, что это такое, какие виды есть и тп. Как хранить граф. Посчитать следующие вещи:

1. Сколько памяти на хранение в зависимости от n - числа вершин, m - числа ребер

2. Время на то, чтобы узнать, есть ли ребро между двумя вершинами

3. Время на то, чтобы перебрать все ребра

4. Как выглядит в случае ориентированных, неориентированных, мультиграфы(имеет петли), с кратными ребрами и взвешенными графами

Для матрицы это

1. $O(n^2)$
2. $O(1)$
3. $O(n^2)$

Для списка смежности это

1. $O(m)$
2. $O(n)$
3. $O(m)$

Объяснить, почему это так.

Можно еще рассказать про матрицу инцидентности. Это когда строки матрицы - номера вершин, а столбцы - номера ребер. Используется крайне редко(пока встречал только в доказательствах теорем).

К слову, автор этого текста в задачах на графы обычно нумерует вершины начиная с 1. Это позволяет использовать входные данные как есть, но нужно выделять больше памяти в массивы(на 1 больше). Можно нумеровать и с 0, кому как удобнее.

После рассказываем bfs.

Вариантов рассказать его довольно много. Не стоит сразу переходить к очереди, до нее нужно дойти итеративно. Много рисунков, показываем, в каком порядке мы финализируем расстояния до вершин. bfs спокойно пишется и без очереди, а просто на векторе. В конец мы просто добавляем новые обработанные вершины. Однако по такому вектору мы идем слева направо, поэтому часть первых элементов в нем нам уже не нужна. Отсюда и вытекает очередь. Более того, в этом векторе вершины будут лежать в отсортированном по длине пути порядке. Такой поход к рассказу позволит далее легко переходить к модификациям bfs.

Задачи, которые решает bfs все основаны на одном - найти кратчайшее расстояние от стартовой вершины до всех соседних.

Такой алгоритм работает и для ориентированных, и для обычных.

Также предлагается нарисовать детям что-то вида дерева обхода DFS, но в случае BFS. Это, конечно, уже не дерево, но бывает полезно. Это когда на 1 уровне рисунка находится корень, на втором - его соседи, на третьем - вершины на расстоянии 2 от корня и так далее.

Тут стоит спросить, как в таком виде выглядят ребра графа. Ответ зависит от типа графа. Для неориентированных графов ответ - все ребра лежат либо на 1 уровне, либо на двух соседних. Для ориентированных картинка уже менее приятная, такой случай можно не рисовать.

На основе такого дерева предлагается рассмотреть задачу:
_Посчитать кратчайшее расстояние от стартовой вершины до всех остальных, но помимо этого посчитать кол-во таких кратчайших путей для каждой вершины_

Потом переходим к 0-1 BFS.

В зависимости от того, на каком уровне рассказали обычный bfs, перейти к нему будет либо очень просто, либо довольно сложно. 

_Если вдруг ваша аудитория достаточно сильна, вы успели прочесть всё до этого момента и у вас остается больше часа, можно рассказать 1-k bfs. Задач на него не будет, он полезен скорее только как переход от bfs к Дейкстре._


Справочные материалы:

[Основные определения](https://wiki.algocode.ru/index.php?title=%D0%93%D1%80%D0%B0%D1%84%D1%8B_-_%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D0%BD%D1%8B%D0%B5_%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

[Способы хранения графов](https://wiki.algocode.ru/index.php?title=%D0%A5%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B3%D1%80%D0%B0%D1%84%D0%B0)

[bfs](https://wiki.algocode.ru/index.php?title=BFS)

[0-1 bfs](https://wiki.algocode.ru/index.php?title=0-1_BFS)

[1-k bfs](https://codeforces.com/blog/entry/88408)