Запросы на отрезке 2
======================
```
Дерево отрезков с модификациями на подотрезке
Дерево отрезков "снизу"
Merge Sort tree
Динамическое дерево отрезков
Двумерное дерево отрезков
Метод сканирующей прямой
```

Урок скорее всего будет тяжелым, хотя информации тут не так много. Просто воспринимается этот материал обычно с трудом. Постараться максимально плавно рассказать про каждую из структур данных. Можно в поряде занятия поменять местами динамическое ДО и ДО с массовыми.

# Дерево отрезков с модификациями на подотрезке

Тут полезно давать много рисунков.

[ссылка](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9D%D0%B5%D1%81%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F._%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%BC%D0%B0%D1%81%D1%81%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BE%D0%B1%D0%BD%D0%BE%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)

[ссылка(ближе к концу страницы, но и всё прочесть полезно](https://e-maxx.ru/algo/segment_tree)

# Дерево отрезков "снизу"

_Рассказывать его не надо. Сказать, что есть, дать ссылки для самостоятельного изучения_

Эффективная версия ДО. Есть варианты и для одиночных изменений, и для массовых. Все же стоит использовать только для одиночных, иначе теряется смысл(а он в безумной скорости такого ДО).

К тому же, пишется оно намного быстрее, чем обычное. Но, к сожалению, детям скорее всего придется просто запомнить реализацию, тк обоснование не самое простое.

[Я в свое время изучал по этой ссылке, но тут на английском](https://codeforces.com/blog/entry/1256?locale=ru)

[ссылка](https://peltorator.ru/posts/down_segment_tree/)

[ссылка](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D0%B0_%D0%B2_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%B5_%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%BE%D0%B2_%D1%81%D0%BD%D0%B8%D0%B7%D1%83)

# MergeSort-Tree

Очень простая структура данных. Идея - в вершине ДО мы храним отсортированный по значению список элементов, за которые эта вершина отвечает. Строится оно как обычное ДО, очень похоже на алгоритм merge sort. Позволяет находить ответы на запросы по типу _сколько элементов на отрезке меньше заданного числа Х_. Памяти требует $O(n log(n))$, ответ на запрос как правило работает за $O(log^2(n))$, но зависит от запроса конечно же.

# Динамическое дерево отрезков

Идея в том, что мы иначе организуем индексы для нашего ДО. Если раньше для каждого номера вершины мы явно задавали левого и правого сына, то теперь мы не будем это делать никак. В больших массивах данные не всегда все верщины ДО в целом будут посещены. Тут 2 варианта работы

1. Вкратце идея: У каждой вершины теперь свой индекс в массиве ДО, его можно хранить в массиве index[]. Всякий раз, когда переходим в вершину, смотрим на нужный индекс из массива. index[] заполняем лениво, по мере востребования. Идея более подробно: Будем хранить массивы leftIndex и rightIndex. Это индексы левого и правого сына вершины v. Изначально они все -1. Как только вам нужно сделать переход в вершину, вы смотрите, а назначен ли индекс перехода в этого сына. Если да -- просто переходите. Если нет, то выделяете ему новый индекс, а после этого переходите. Как выделять индекс? Давайте сразу создадим большой массив tree, который будет хранить значения вершин. Но изначально он будет пустой(вернее сказать, в нем будет лежать лишь информация о корне). Также будем поддерживать переменную total. Изначально она равна 1. Всякий раз, когда вам нужно создать индекс для сына, вы смотрите на total и говорите, что его индекс и равняется total. После чего увеличиваете total на один. Получается, что на один запрос может быть создано порядка $log(C)$ новых вершин. Опять таки создано в смысле под них будут выделены индексы.

2. Второй способ, это делать то же самое, но на указателях. Т.е. нужно выделять память под структуру через new. См ссылку

[ссылка](https://wiki.algocode.ru/index.php?title=%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)

# Двумерное дерево отрезков

Это дерево отрезков, в вершине которого хранится еще одно дерево отрезков. Обычно такое реализуют с помощью указателей. Задачи на него с 1d переносятся на 2d. Вместо дан массив -- дана матрица. Вместо суммы на подотрезке -- сумма на подпрямоугольнике. Также меняется какой-то элемент матрицы.

Просто рассказать, что такое есть.

# Метод сканирующей прямой

Это просто метод, когда мы идем по так называемым ивентам в некотором порядке. Это позволяет обрабатывать входные данные в удобном для ДО формате. Так же, как и ДП, тема познается в решении задач.


[немного информации и задачи](https://informatics.msk.ru/pluginfile.php/355322/mod_resource/content/0/Metod_skaniruyuschei_pryamoi.pdf)

[почти та же информация, но другими словами](https://algocode.ru/page/c-9-scanline/)a