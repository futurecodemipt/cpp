

## Понятие дерева

Рассказать определения:

1. Дерево
2. Поддерево
3. Предки и потомки
4. корневое и некорневое дерево
5. родитель и дети


## Обход дерева

Написать простой dfs - обход по дереву

Если мы храним граф в виде списка смежности, то может быть так:

```c++
void dfs(int v, int p) {
    for (auto u : g[v]) {
        if (u == p) {
            continue;
        }
        dfs(u, v);
    }
}
```

## ДП на поддеревьях

Любое дп на дереве выглядит как правило так:

Запускаем dfs, сначала обрабатываем детей вершины, потом саму вершину. Листья как правило являются базой динамики.

Разобрать несколько задач на эту тему. Примеры ниже:

далее везде такая терминология 

* l - лист
* v - вершина
* u -- дети вершины v
* $max$(...) - максимум
* $max_k$(...) - k-ый максимум
* $ch[v]$ - кол-во детей $v$

---------------

Размер поддерева:

База: $sz[l] = 1$

Переход: $sz[v] = 1 + \sum sz[u_i]$

------------

Пусть путь измеряется в ребрах.

$toLeafMax[v]$ - самый длинный путь из $v$ до листа

База: $toLeafMax[l] = 0$

Переход:  $toLeafMax[v] = max(toLeafMax[u_i]) + 1$


* Самый длинный путь, где $v$ - самая верхняя на пути:
$k[v] = ch[v] > 1$ ? $2 + max_1(toLeafMax[u_i]) + max_2(toLeafMax[u_i])$ : $toLeafMax[v]$
* Самый длинный путь(или же диаметр) $max_v(k[v])$

--------------------

Кол-во всех путей (тут уточнение, разрешаем ли путь, который состоит из 1 вершины, допустим, разрешаем)

$down[v]$ - кол-во путей из $v$ вниз.

База: $down[l] = 1$

Переход $down[v] = 1 + \sum_{i}(down[u_i])$

_Тут можно заметить, что down[v] = sz[v]_

$highest[v]$ - кол-во путей, таких что $v$ на этом пути - самая верхняя

База: $highest[l] = 1$

Переход: $highest[v] = down[v] + \sum_{i \neq j} (down[u_i] * down[u_j])$

где

* $down[v]$ -- путь из $v$ строго вниз в поддерево $u_i$
* $\sum_{i \neq j} (down[u_i] * down[u_j])$ -- путь, где $v$ - самая верхняя вершина, который начинается где-то в поддереве $u_i$, заканчивается в поддереве $u_j$ и проходит через $v$

Чтобы это было легче пересчитывать, введем доп массивы:

$sq[v] = \sum_{i}(down^2[u_i])$

$sum[v] = \sum_{i}(down[u_i]), sum^2[v] = \sum_{i}(down^2[u_i]) + \sum_{i \neq j}(2down[u_i] \cdot dp[u_j])$

$sum^2[v] = sq[v] + 2 \cdot \sum_{i \neq j}(down[u_i] \cdot down[u_j])$

Они все пересчитываются за $O(n)$

Тогда $highest[v]$:

$highest[v] = down[v] + \frac{sum^2[v] - sq[v]}{2}$

Теперь кол-во всех путей в дереве это $\sum_v (highest[v])$

---------------


$all[v]$ - кол-во путей, проходящих через $v$.

Ответ складывается из динамики из предыдущей задачи и еще 1 компоненты

$up[v]$ - кол-во путей, начинающихся в $v$, которые затем идут к родителю $v$ и дальше куда-то

$all[v] = highest[v] + up[v] \cdot down[v]$

Как считать up:

$up[v] = up[p] + down[p] - down[v]$

* тут тоже видна 1 закономерность, $up[v] + down[v] = const = down[S] = sz[S]$.
тогда $up[v] = n - down[v]$, а сам $all[v] = highest[v] + (n - down[v]) \cdot down[v]$. Для некоторых задач такую оптимизацию уже не сделать, поэтому все равно рассказываем, как считать up честно

$up[v]$ придется считать не снизу вверх, а сверху вниз. Т.е. базой для него будет корень дерева $S$: $up[S] = 0$

---------------

Стоит отметить, что часть таких задач требуют, чтобы дерево было подвешено за конкретную вершину S. Выбор S не всегда принципиален и не всегда дается. Есть еще вариант динамики для неподвешенного дерева, но это довольно сложно и редко когда нужно. Мы это рассматривать не будем.



## Ссылки

[2 хорошие задачи](https://neerc.ifmo.ru/wiki/index.php?title=%D0%94%D0%B8%D0%BD%D0%B0%D0%BC%D0%B8%D0%BA%D0%B0_%D0%BF%D0%BE_%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D1%8C%D1%8F%D0%BC)