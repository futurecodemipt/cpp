```
ДП на подотрезках
Работа с битовыми масками
ДП на подмасках
```

ДП на подотрезках:

во всех задачах ровно одна идея, нужно посчитать некоторое значение на отрезке [l; r], зная значения на отрезках меньшей длины.

В лучшем случае это будет работать за $O(n^2)$, но в некоторых задачах может быть $O(n^3)$ или даже больше.

Рассмотрим пример:

_На доске записана последовательность натуральных чисел. За один ход разрешается выбрать два соседних числа в последовательности и заменить их на их среднее арифметическое. Будем делать ходы до тех пор, пока на доске не останется одно число. Какое максимальное число может получиться?_

Посчитаем $dp_{l, r}$ - ответ, если рассматривать только подотрезок [l, r]. 

База: $dp_{i, i} = a_i$

Переход: перед тем, как получить ровно 1 число, было состояние, в котором было два числа. Каждое из них было получено из каких-то подмассивов. Т.е. первое было получено из подмассива [l; x], а второе - из [x + 1, r]. Но какое число стояло в [l; x]? Нам бы хотелось видеть максимальное из возможных. Этот ответ хранится в $dp_{l, x}$. Также и с [x + 1; r]. Но это все было из предположения, что полученные два числа пришли именно из таких подмассивов. Чтобы обработать любой случай достаточно перебрать все такие x. Т.е. ответ такой $dp_{l, r} = max(\frac{dp_{l, x} + dp_{x + 1, r}}{2}) | x \in \{l, l + 1, ..., r - 1\}$

Пересчет: Обычно(но не всегда) пересчитывают в таком порядке

```c++
for (int len = 2; len <= n; ++len) {
    for (int left = 1; left + len <= n; ++left) {
        int right = left + len - 1;
        // dp[left][right] = ...
    }
}
```

В этой задаче:

```c++
for (int len = 2; len <= n; ++len) {
    for (int left = 1; left + len <= n; ++left) {
        int right = left + len - 1;
        for (int mid = left; mid < right; ++mid) {
            dp[l][r] = max(dp[l][r], (dp[l][mid] + dp[mid + 1][right]) / 2);
        }
    }
}
```

_В этой задаче код перехода нужно немного переписать, тк среднее может быть нецелым. Код выше задачу не сдаст, но дан для примера._

Т.е. перебирают все длины от самой маленькой до самой большой. А внутри уже перебирают отрезки такой длины

Время работы такого алгоритма $O(n^3)$, тк нужно перебрать все отрезки и в каждом из них перебрать разбиение на 2 подотрезка.

Бывают и другие переходы, самый простой это переход вида dp[l][r] = f(g(a[l], dp[l + 1, r]), g(dp[l, r - 1], a[r])), где f и g какие-то функциию

-------------

Битовые маски

Маска - это просто число. Нас же интересует на каких битах какие значения стоят. Напишем несколько функций

* $\text{<< k}$ - битовый сдвиг вправо. По сути умножает число на $2^k$.
* $\text{>> k}$ - битовый сдвиг влево. По сути делит число на $2^k$.

```c++
uint get(uint mask, uint i) { // i-ый бит
    return (mask >> i) & 1
}
uint inverse(uint mask, uint i) { // меняет i-ый бит на противоложный
    return mask ^ (1 << i);
}
uint set1(uint mask, uint i) { // ультимативно ставит i-ый бит как 1
    return mask | (1 << i);
}
uint set0(uint mask, uint i) { // ультимативно ставит i-ый бит ка к 0. Можно намного лучше
    return mask & ((uint(-1)) - (1 << i))
}
```

Если мы храним число в k-битном типе, то такое число может кодировать $2^k$ различных вариантов.


ДП на подмасках:

Похоже на дп на подотрезках, но переход идет не по вложенным отрезкам, а по вложенным  подмножествам.

Рассмотрим пример:

_Продавец аквариумов для кошек хочет объехать n городов, посетив каждый из них ровно один раз. Помогите ему найти кратчайший путь. Расстояния $a_{i, j}$ даны_

Сразу перейдем к 0-индексации вершин.

рассмотрим dp[mask][last]. Там где в mask стоят 1, это те города, которые уже посетили. last - номер последнего посещенного города.

База: $dp[set1(0, i)][i] \text{  }|\text{  } i \in \{1, 2, ..., n\} $

Переход:

Зафиксировали mask и last

перебем все вершины $j$, которые не были посещены

```c++
for (int j = 0; j < n; ++j) {
    if (get(mask, j)) continue;
    // если здесь, значит j в маске нет
}
```
Попытаемся перейти в новую маску

```c++
for (int j = 0; j < n; ++j) {
    if (get(mask, j)) continue;
    uint new_mask = set1(mask, j);
    dp[new_mask][j] = dp[mask][i] + a[i][j];
}
```

Вот так писать неправильно, частая ошибка. В dp[new_mask][j] могло лежать какое-то значение, поэтому нужно брать минимум. И не забывать обрабатывать ситуацию, когда там еще нет значения. Введем для этого массив used

```c++
for (int j = 0; j < n; ++j) {
    if (get(mask, j)) continue;
    uint new_mask = set1(mask, j);
    if (!used[new_mask][j] || dp[new_mask][j] >= dp[mask][i] + a[i][j]) {
        used[new_mask][j] = true;
        dp[new_mask][j] = dp[mask][i] + a[i][j];
    }
}
```


Ответ в этой задаче - минимум по всем dp, что мы посчитали

```c++
uint all1 = (1 << n) - 1;
unsigned long long ans = *std::min_element(dp[all1], dp[all1] + n);
```

## Ссылки

[задача на разбор](https://habr.com/ru/articles/112386/)

[вариации задач дп по подмножествам](https://codeforces.com/blog/entry/337?locale=ru)