## Определение LCA

Рассказать, что это такое.

Тут же можно рассказать/напомнить про метод временных меток, который позволяет проверить, является ли одна вершина предком другой.

Запускается dfs на дереве. С каждым шагом dfs увеличивается глобальная временная метка.
Для вершины запомним $tin[v]$ - метка, когда впервые попали в дерево и $tout[v]$ - метка, когда в последний раз были в дереве. $a$ является предком $b$, если и только если $tin[a] < tin[b] \leq tout[b] < tout[a]$.

## двоичные подъемы

Хочется дать формально, что это такое, а не только, как считать lca с их помощью.

Пусть вам нужно посчитать некую f на пути. Здесь длина пути - кол-во ребер на пути, а f в принимает вершины.

На нее накладываются ограничения, например, такие:

f(a, b, c, d) = f(f(a, b), f(c, d))

Давайте посчитаем эту f для путей от $v$ до корня, причем для длин путей равных $2^k$. Хранить ответ будем в $F_k[v]$

$p_k[v]$ - родитель $v$ на расстоянии $2^k$

$F_k[v] = f(F_{k-1}[v], F_{k-1}[p_{k-1}[v]])$

При этом $F_0[v] = f(v)$

Дело в том, что благодаря двоичным подъемам, мы можем считать f на пути произвольной длины, главное, чтобы этот путь был от некой вершины строго вверх.

## решение lca через двоичные подъемы

Тут функцией f на пути является самая верхняя вершина на пути. Т.е. по сути подсчет сводится к нахождению $p_k[v]$.

Даны две вершины, пусть a и b.

1. Сначала проверим, вдруг a уже предок b.
2. Если нет, начнем смотреть предков $p_k[v]$ по уменьшению k. Пока $p_k[v]$ - предок b, уменьшаем k. 
3. Как только $p_k[v]$ больше не предок b, делаем a = $p_k[v]$ и возвращаемся к предыдущему шагу. Заметим, что k всегда уменьшается на 1, заново начинать с k = k_max не надо.

```c++
if (is_ancestor(a, b)) {
    return a;
}
for (int k = k_max; k >= 0; --k) {
    if (!is_ancestor(p[k][a], b)) {
        a = p[k][a];
    }
}
lca = p[a];
return lca;
```

## решение через RMQ

Очень красивое сведение задачи. Сделаем эйлеров обход дерева. Выпишем все вершины в том порядке, в котором они встретились - массив $path$. Зафиксируем две вершины $a$ и $b$, нам нужно найти их lca  $c$. Выберем произвольное вхождение $a$ в массиве обхода - $index_a$ и произвольное вхождение $b$ в массив обхода - $index_b$. Пусть для простоты $index_a < index_b$. Утверждается, что на отрезке $[index_a;index_b]$ в массиве $path$ обязательно встретится и их lca $c$. Более того, что при этом и самое важное, этот $c$ в этом отрезке будет вершиной с самой маленькой глубиной. Получается, задача сводится к тому, чтобы найти отрезок и на отрезке в массиве найти минимум.В этом месте нам поможет sparse table.

В $path$ удобно хранить не просто вершины, а пары (глубина вершины, номер вершины). Тогда найдя минимум, мы сразу узнаем, на какой вершине он достигается. В качестве произвольного вхождения можно выбрать действительно произвольное, например, самый первый индекс в $path$, где встретилась вершина. Эти значения сохраняются на этапе предобработки.

## Алгоритм Фарака-Колтона и Бендера

Это не обязательная часть.

Можно рассказать этот алгоритм, как оптимизацию решения через RMQ.

## Сливаемые сеты

Пусть дано два множества. Что если нам нужно их объединить? Давайте элементы меньшего множества добавлять в большее множество. На этом всё. Утверждается, что такой подход работает достаточно быстро.

А именно, пусть всего множеств $k$, в сумме элементов $n$, время на добавление элемента в множество пусть будет $O(f(n))$.

Пусть алгоритм работает х шагов, на каждом шаге выбирается два множества, которые нужно объединить в одно. Тут несколько вариантов

* Создать новое множество и добавить в него элементы старых двух множеств
* Все элементы из большего множества добавить в меньшее множество
* Все элементы из меньшего множества добавить в большее множество 

Нам следует выбрать последний вариант.

Тогда суммарное время работы будет $O(n \cdot log(n) \cdot f(n))$

Почему так? Каждый элемент изначально лежит в каком-то множестве. Давайте заметим, что когда он попадает в другое множество, размер множества, где он лежит, увеличивается не меньше чем в 2 раза. Т.е. всего он будет перемещаться $log(n)$ раз. Каждое перемещение занимает $f(n)$ времени, а всего элементов у нас $n$.



## Ссылки

[lca через двоичные подъемы](https://neerc.ifmo.ru/wiki/index.php?title=%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B4%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D0%B4%D1%8A%D1%91%D0%BC%D0%B0)

[lca через RMQ](https://neerc.ifmo.ru/wiki/index.php?title=%D0%A1%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8_LCA_%D0%BA_%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B5_RMQ)