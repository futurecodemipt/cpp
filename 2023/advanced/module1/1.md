Бинарный поиск
================

```
Введение в асимптотику
Бинарный поиск
Бинарный поиск по ответу
Сортировка 
Сортировка слиянием
Поиск числа инверсий
```


# Введение в асимптотику

Рассказать что такое асимптотика и как её считать

Можно это делать на примере программ с конечным числом действий, циклов

Рассмотреть следующие примеры

$O(1)$
```c++
int main() {
    int x = 5;
    std::cout << x;
}
```
$O(n)$
```c++
int main() {
    int n;
    std::cin >> n;
    for (int i = 0; i < n; ++i) {
        std::cout << i << " ";
    }
}
```
$O(n^2)$
```c++
int main() {
    int n;
    std::cin >> n;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << i * j << " ";
        }
    }
}
```

$O(nm)$
```c++
int main() {
    int n;
    std::cin >> n;
    int m;
    std::cin >> m;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            std::cout << i * j << " ";
        }
    }
}
```

$O(2^n)$

```c++
int main() {
    int n;
    std::cin >> n;
    int m;
    std::cin >> m;
    for (int i = 0, up = 1; i < n; ++i, up *= 2) {
        for (int j = 0; j < up; ++j) {
            std::cout << j << " ";
        }
        std::cout << "\n";
    }
}
```


Объяснить, почему $O(2n) = O(n)$, $O(n^2 + n) = O(n^2)$

Это можно сделать, например, дав определение $O$

Говорят, что $T(n) = O(f(n))$, если $\exists C, N_0 \forall n \ge N_0$ $(T(n) \lt C\cdot f(n))$

Также, можно считать, что в одной секунде примерно $10^8$ действий.
На это число можно ориентироваться при подсчете времени работы кода, но не всегда.

# Бинарный поиск

В этом пункте детям потребуются небольшие знания логарифма. Больше, чем логарифм по основанию два им не потребуется.

Т.е. нужно дать определение логарифма, и примеры на него

Также, некоторые формулы со степенями двойки, например:

$$1 + 2 + 4 + ... 2^{n-1} + 2^{n} = 2^{n+1} - 1 = O(2^n)$$

Сам бинарный поиск можно рассказать на примере задачи:

Дан отсортированный массив. Приходят $q$ запросов, каждый из них вида: _дано число x, найти минимальный элемент массива такой, что он больше или равен этого x. Вывести этот элемент_

Бинарный поиск лучше стрататься писать в виде работы с полуинтервалами.

А именно, мы предполагаем, что искомый элемент изначально лежит на индексах из $[from, to)$. Рассматриваем середину mid и понимаем, куда переходить. Либо в $[from; mid)$, либо $[mid; to)$. Как можете видеть, из полуинтервала переходим в полуинтервал. Это важно донести до детей.

Также, в конце работы алгоритма, вопрос, а где лежит ответ? Тк мы храним на полуинтервале, ответ лежит на той границе, которая была включена в полуинтервале


```c++
int from = 0;
int to = n;

while (from < to) {
    int mid = (from + to) / 2;
    if (a[mid] >= x) from = mid; // [mid; to)
    else to = mid; // [from; mid)
}
std::cout << a[from];
```


# Бинарный поиск по ответу

На самом деле, не стоит выносить в отдельный пункт темы, но иногда задачи такие встречаются. Смысл в том, что бин поиск делается не по индексам массива, а по ответу, который нужно вывести на экран.

Типичная задача, сколько минимум денег нужно, чтобы сделать _что-то_.
Делаем бин поиск по кол-ву этих денег и смотрим, получается ли сделать это _что-то_. Если получается, имеем границу сверху. Если не получается, то снизу. Пример задачи - _Коровы в стойла_

# Тернарный поиск

Тернарник не сильно отиличается от бинпоиска, поэтому много времени не займет. Рассказать про поиск минимума решения $y = ax^2 + bx + c$, $a > 0$ в качестве примера.
После сказать, что любая функция имеющая ровно 1 точку минимума/максимума на отрезке решается аналогичным образом.

# Сортировка

Дан массив, необходимо его отсортировать. Предложить придумать какой-нибудь алгоритм сортировки. Рассмотреть несколько алгоритмов сортировки за $O(n^2)$.

# Сортировка слиянием

В этом пункте нужно написать алгоритм _Сортировка слиянием_

Удобно делить его на 2 части

1. Написать функцию, которая объединяет два отсортированных массива в один отсортированный массив за $O(n + m)$

2. Сама сортировка слиянием. Делим массив на две половины, каждую сортируем, а потом сливаем за линию.

Объяснить, почему асимптотика алгоритма $O(n\cdot log(n))$

# Поиск числа инверсий

Дан массив, найти число инверсий в массиве. Давайте его отсортируем. Это можно делать с помощью сортировки слиянием. В момент слияния, всякий раз, когда мы берем элемент из правой половины, а не из левой, увеличиваем счетчик на единицу.
