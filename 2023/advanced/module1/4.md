Запросы на отрезке1
======================
```
Задачи RSQ, RMQ, static RSQ
Префиксные суммы. Возможные операции
Sparse Table. Возможные операции
Дерево отрезков с модификациями в точке
```

RSQ:

Дан массив чисел. Приходят запросы вида [l, r]. Посчитать сумму чисел на подотрезке с l-ого индекса по r-ый индекс.

Далее идут варианты, может ли быть еще один тип запросов и какой.

1. Запрос вида [index, value]: изменить значение index-ого элемента массива на value ($a_{index} = value$)

2. Запрос вида [index_l, index_r, value]: изменить значение всех элементов на подотрезке [index_l, index_r] на value ($a_{index_l} = value$, $a_{index_{l+1}} = value$, ..., $a_{index_{r - 1}}$, $a_{index_{r}} = value$)

3. Некоторые модификации запроса 2, например, изменить на минимум, прибавить число и тп. Можно показать, что научившись решать запрос 2, то мы научимся решать и запрос 3.

Решение задачи без запросов 1-3 это Префиксные(Частичные) суммы.

С запросом 1 -- Дерево отрезков с обновлением в точке

С запросом 2 -- Дерево отрезков с массовыми операциями

RMQ:

Дан массив чисел. Приходят запросы вида [l, r]. Посчитать минимум чисел на подотрезке с l-ого индекса по r-ый индекс.

Варианты запросов те же.

Решение задачи без запросов 1-3 это Sparse Table.

С запросом 1 -- Дерево отрезков с обновлением в точке

С запросом 2 -- Дерево отрезков с массовыми операциями


-----------------------

Итого, такие задачи разбиваются на 3 типа:

1. Без изменений массива, т.е. static. Префиксные суммы / Sparse Table

2. Изменения массива в точке -- ДО

3. Изменение массива на подотрезке -- ДО с массовыми

В этом уроке мы не рассматриваем 3-ий тип задач, только первые два. Причем последовательно.

План следующий: в начале Префиксные суммы, потом Sparse Table, потом Дерево отрезков

В каждой части рассказать

1. задачу, которую решает эта структура данных
2. какие варианты задачи могут быть и какие не могут быть(и почему)
3. Асимптотику памяти на хранение структуры
4. Асимптотику времени на построение структуры
5. Асимптотику времени на ответ на запрос

Префиксные суммы:

1. Сумма чисел, xor чисел на подотрезке, массив подсчета на подотрезке
2. min/max не может быть. Пусть первый элемент 0, ищем минимум. Тогда все преф минимумы будут 0, не извлекаем никакой инфы. Вообще, операция должна обладать свойством существования обратного элемента, чтобы решалась преф. структурами. У минимума такого нет. У xor обратным является тот же элемент.
3. $O(N)$
4. $O(N)$
5. $O(1)$

Sparse Table:

1. Min/Max на подотрезке. Битововое &, |
2. Операция OP в общем случае должна обладать следующим свойством OP(a, a) = a. Для суммы, произведения и тп это не выполняется.
3. $O(N\cdot log(n))$
4. $O(N\cdot log(n))$
5. $O(1)$

Также стоит рассказать, как искать не просто минимум/максимум а еще и позицию минимума/максмума. Это можно сделать по-разному. Один из вариантов - хранить не элемент, а пару {элемент, его индекс}. Тогда не меняя код алгоритма, мы получим и нужный минимум, и его позицию(для std::pair определены min, max функции, это тоже стоит рассказать.)

Дерево отрезков:

1. Все адекватные операции
2. Операция OP в общем случае должна обладать свойством ассоциативности.
3. $O(N)$
4. $O(N)$
5. $O(log(n))$ на запрос ответа, $O(log(n))$ на запрос изменения элемента

_Сравочные материалы:_

# Префиксные суммы

[ссылка](https://codeforces.com/blog/entry/88474?locale=ru)

# Sparse Table

[ссылка](https://wiki.algocode.ru/index.php?title=Sparse_Table)

# Дерево отрезков с модификациями в точке

Тут полезно давать много рисунков. Рассказывать про построение можно начать как с корня, так и с листов. В начале build, потом запрос изменения, и самое сложное - запрос get. Про асимптотику get дети могут сходу не понять, почему она такая.

[ссылка](https://wiki.algocode.ru/index.php?title=%D0%94%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BE%D1%82%D1%80%D0%B5%D0%B7%D0%BA%D0%BE%D0%B2)
