```
SQRT-декомпозиция
Алгоритм Мо и его модификации
```

SQRT-декомпозиция может встретиться в разных задачах под разным видом. Главный смысл в том, чтобы разделить входные данные на блоки, где размер блока порядка корня, от рамера входных данных.

Предлагается рассмотреть несколько задач на эту тему

[Простая задача для начала](https://wiki.algocode.ru/index.php?title=%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%B4%D0%B5%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F_%D0%BD%D0%B0_%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D0%B5) 


-----------------


_Сложная задача(опциональная): дан массив размера n, приходит q запросов вида (перевернуть отрезок массива с l по r), и (посчитать сумму на отрезках с l по r)._

Разделим массив на блоки, размера k. В каждом блоке будем хранить сумму элементов в этом блоке и сами элементы. Также будем хранить флаг, правда ли элементы внутри блока лежат в нужном порядке, или же их нужно перевенуть.

Операцию переворачивания будем обрабатывать так:

Смотрим, какие блоки полностью попали в отрезок запроса, слева и справа от них могут быть блоки, которые попали частично.

Чтобы перевернуть элементы внутри блока, просто запишем в флаг этого блока, что элементы там перевернуты. В тех блоках, которые попали не полностью, честно перевернем ту часть, которая попала в запрос. Также заметим, что недостаточно просто перевернуть элементы внутри блоков, нужно поменять порядок и самих блоков. Чтобы это сделать быстро, будем хранить массив указателей на блоки(или же хранить блоки в массиве, а адреса блоков будут индексы в этом массиве). Когда приходит запрос на переворот, будем переворачивать сами блоки в этом массиве блоков(помимо того, что нужно сделать для самих блоков).

Итого, это работает за 

1. 2 * k -- честно перевернуть элементы в крайних блоках
2. n / k - проставить флаги в блоках
3. n / k - поменять порядок самих блоков.


$$O(k + \frac{n}{k})$$

Как будем отвечать на запрос суммы? Посмотрим, какие блоки полностью попали в запрос, у них спросим полностью сумму, которая уже посчитана для любого блока и хранится вместе с блоком - O(n / k). А для крайних блоков честно пробежимся по элементам и посчитаем сумму - O(2 * k).

$$O(k + \frac{n}{k})$$

Итого, какой k нужно взять? Несложно показать, что самый лучший k здесь будет $k = \sqrt{n}$.

_Стоит отметить, что помимо того, что написано выше, для каждого блока, если мы честно пробегаемся по его элементам, нужно посмотреть на его флаг, и если что перевернуть его элементы_

Однако задача на этом не заканчивается. Дело в том, что иногда просто переворачивать сами блоки тоже не совсем верно. Так можно делать, только если отрезок попал ровно в границы блоков. Если это не так, то те крайние блоки, которые частично попали в запрос, нужно разделить на 2 блока каждый. А затем после этого уже переворачивать блоки. С другой стороны, если так делать, то кол-во блоков будет расти, поэтому помимо этого нужно иногда наоборот объединять блоки, если мы видим несколько подряд идущих блоков(чтобы их суммарный размер стал порядка корня). Это можно делать, например, во время поиска блоков для отрезка, который нас интересует, правда, довольно грамотно, иначе асимптотика возрастет. Или же каждые $\sqrt{q}$ запросов заново пробегаться по всему массиву и создавать блоки заново.


--------

Есть задачи, где k не является корнем из n, он может быть корнем из n * log(n) или нечто другое, и зависит это от самой задачи. Считаете асимптотику и понимаете, какой k лучше подходит.

--------

Алгоритм МО

Еще 1 вариант декомпозиции, но тут скорее делятся сами запросы, а не массив. Есть отдельный пул задач, которые можно решить с его помощью.

Предлагается разобрать всё отсюда до пункта про деревья(мо на дереве и 3d мо трогать не будем)

[ссылка](https://ru.algorithmica.org/cs/decomposition/mo/)

----------

Еще задачи на разбор (эта задача в классной работе)

[Задача](https://codeforces.com/contest/13/problem/E)

[Разбор E](https://codeforces.com/blog/entry/364)

-------

[P5](https://codeforces.com/blog/entry/96713)

[Полуразбор](https://wiki.algocode.ru/index.php?title=%D0%9A%D0%BE%D1%80%D0%BD%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BD%D0%B0_%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%D1%85)