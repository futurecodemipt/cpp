# Конструктор
Конструктор вызывается всегда, когда вы создаете объект структуры. По умолчанию, вызывается так называемый _дефолтный_(`default`) конструктор. Есть еще несколько зарезервированных типов конструкторов, но о них чуть позже. Можно определить и пользовательские. Общий синтаксис такой:

```c++
struct Name {
    // код структуры
    Name(Type1 arg1, .., TypeN argN) {
        // Тело конструктора
    }
};
```

Рассмотрим следующий пример:

```c++
struct S {
    int x = 0;
    double y = 0;
    S() {
        std::cout << "default\n";
    }
    S(int newx) {
        std::cout << "int\n";
        x = newx;
    }
    S(double newy) {
        std::cout << "double\n";
        y = newy;
    }
};

int main() {
    S obj1; // Выведет default
    S obj2(5); // Выведет int
    S obj3(3.14); // Выведет double
}
```

Можно давать имя аргументам такое же, как и имена полей. Но тогда придется пользоваться `this`

```c++
struct S {
    int x = 0;
    double y = 0;
    S() {
        std::cout << "default\n";
    }
    S(int x) {
        std::cout << "int\n";
        this->x = x;
    }
    S(double y) {
        std::cout << "double\n";
        this->y = y;
    }
};

int main() {
    S obj1; // Выведет default
    S obj2(5); // Выведет int
    S obj3(3.14); // Выведет double
}
```

`this` связан с такой темой, как указатели, а мы ее пока избегаем. Поэтому давайте пока расскажем его без привязки к указателям. Просто слово. Стрелочка - синтаксис. Это слово обозначает текущий объект, где мы находимся.

-----

Создание через список инициализации:

```c++
struct S {
    int x;
    double y;
};

int main() {
    S s({5, 3.14});
}
```

-----


# Деструктор:

Деструктор вызывается всегда, когда время жизни объекта подходит к концу. Даже если он явно не реализован. Но можно написать пользовательский. Синтаксис:

```c++
struct Name {
    // код структуры
    ~Name() {
        // Тело деструктора
    }
};


Напишем такую структуру:

```c++
struct S {
    S() {
        std::cout << "S";
    }
    ~S() {
        std::cout << "~S";
    }
};
```

```c++
int main() {
    S s;
}
```

Вывод

```
S~S
```


----

Далее показываем как объекты создаются и удаляются внутри функций. А именно, сколько живет та или иная переменная.

-----


# Порядок вызовов конструкторов и деструкторов объектов


----

Порядок создания и удаления полей:

В начале создаются все поля, 
и только после этого сама структура.
В конце удаляется сама структура, 
и только после этого удаляются её поля, причем в порядке, обратном 
их созданию


```c++
#include <iostream>

struct A {
    A() {
        std::cout << "A";
    }
    ~A() {
        std::cout << "~A";
    }
};

struct B {
    B() {
        std::cout << "B";
    }
    ~B() {
        std::cout << "~B";
    }
};

struct C {
    A a;
    B b;
    C() {
        std::cout << "C";
    }
    ~C() {
        std::cout << "~C";
    }
};

int main() {
    C c;
}
```

Вывод:

```
ABC~C~B~A
```

В этом пункте нужно писать много примеров:
Классы, где поля классы. Классы в функциях, в отдельных областях видимости. И для каждого примера посмотреть, когда будут создаваться/удалятся объекты.

Также, к этим примерам добавить ситуации, когда объект является ссылкой на другой, показать, что конструктор не вызывается. И что деструктор у ссылок тоже не вызывается, только у оригинального объекта.

## Вновь ссылки

1. ссылки как аргумент
2. ссылки как возвращаемое значение
3. ссылки как поля

С первым пунктом дети уже должны были познакомиться на прошлых уроках. Но возможно, напомнить определенные моменты.

1. Тут следует показать разницу между просто ссылкой и константной ссылкой. Речь пока идет лишь про lvalue ссылки

2. разобрать следующие примеры

```c++
int& function1() { // not Ok
    int x = 7;
    return x;
}

int& function2(int x) { // not Ok
    return x;
}

int& function3(int& x) { // Ok
    return x;
}

const int& function4(int& x) { // Ok
    return x;
}

const int& function5(const int& x) { // Ok
    return x;
}

const int& myMax(const int& x, const int& y) { // Ok
    return x < y ? y : x;
}
```

первые две функции - пример висячей ссылки. А именно, мы имеем ссылку на переменную, которая уже не существует.


3. ссылки как поля

_member initializer list_:

```c++
struct S {
    int x;
    double y;
    S(int x) : x(x), y(3.14) {};
    S(double y) : x(5), y(y) {};
};

```

Зачем это может пригодиться? Правило следующее. При создании экземпляра стуктуры вначале создаются поля. Так вот, в качестве значения для поля будет выбрано либо дефолтное, либо указанное через = при объявлении поля, либо то, что написано в `member initializer list`. Осознать можно на примере полей -- ссылок


Не скомпилируется, не указано, на что должна ссылаться `ref`:

```c++
struct S {
    int& ref;
    S(int arg) {
        ref = arg;
    }
    void print() {
        std::cout << ref;
    }
};
```


Скомпилируется, но тоже неправильно. `ref` будет ссылкой на локальную переменную `arg`, которая копия переменной `x` из `main`, а не сама `x`. Когда выполнение конструктора завершится, переменная `arg` удалится, а ссылка на нее нет. Это называется `dangling reference` и это `UB`

```c++
struct S {
    int& ref;
    S(int arg) : ref(arg) {
    }
    void print() {
        std::cout << ref;
    }
};

int main() {
    int x = 5;
    S s(x);
    x = 10;
    s.print(); // Скорее всего выведет 5, но это UB
}
```


Только так будет правильно:

```c++
struct S {
    int& ref;
    S(int& arg) : ref(arg) {
    }
    void print() {
        std::cout << ref;
    }
};

int main() {
    int x = 5;
    S s(x);
    x = 10;
    s.print(); // Выведет 10
}
```


```c++
struct ReferenceHolder {
    int& x;
    ReferenceHolder(int& x) : x(x) {};
};

int main() {
    int x = 100;
    ReferenceHolder a(x);
    ReferenceHolder b = a;
    b.x = 200;
    std::cout << x; // Будет 200
}
```

-------

