# Указатели 1

## Краткий план

```
Базовые указатели
Как объекты лежат на стеке
Особенности void*
reinterpret_cast
Оператор new
Оператор delete
Создание и удаление структур
Пример ForwardList
```

__Указатели__

Каждая переменная, которую вы создаете(кроме возможно некоторых констант), лежит в оперативной памяти. А значит, у нее есть адрес. Почти на всех современных компьютерах этот адрес записывается 64 битам, т.е. 8 байтами. Для адреса в памяти существуют отдельные типы, которые хранят этот самый адрес.

Если переменная `x` имеет тип `Type`, то её адрес можно хранить в переменной типа `Type*`. Такие переменные называют указателями.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int; // В этой переменной можно хранить адрес любого int
    double* ptr_double; // В этой переменной можно хранить адрес любого double
    char* ptr_for_symbol; 
    std::cout << sizeof(ptr_int); // Будет 8
}
```
Как получить адрес переменной? Для это есть унарный оператор `&`
```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
}
```

Как вывести адрес? С этим справится обычный `cout`. Только нужно помнить, что он выводит адреса в 16-ричном формате.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
}
```

_Уточнение_: Если попытаетесь так вывести адрес переменной типа `char`, то адрес вы не увидите. Это связано с тем что тип `char*` используется немного в другом контексте, а именно для C-style строк.

А если у вас есть адрес переменной, то как получить то, что под ним лежит, т.е. саму переменную?

Для этого есть унарный оператор `*`, который применяют к указателю(говорят, что указатель разыменовывают)


```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    std::cout << *ptr_int << "\n"; // Выведет 15
    x += 1;
    std::cout << *ptr_int << "\n"; // Выведет 16
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
    std::cout << *ptr_double << "\n"; // выведет 3.14
    y = 0;
    std::cout << *ptr_double << "\n"; // выведет 0
}
```

Применяя `*` к указателю вы получаете ту переменную, на которую он ссылается, поэтому в частности можно делать так:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr = &x;
    *ptr = 2; // Все равно что написать x = 2
    std::cout << x; // Будет 2
}
```
Базовые операции с указателем:
1. унарный *
2. +- число
3. - указатель

1 уже был рассмотрен, далее 2 и 3:

_Далее предполагается, что стек у вас направлен положительно, т.е. чем позже объявлена переменная, тем больший у неё адрес. Не везде это так(Например, Windows)_

```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
}
```
Вы получите 3 строчки адресов, но можно заметить, что все они идут через 4 в 16-ричном формате. Это связано с тем, что размер `int` - 4 байта, и эти переменные идут в памяти подряд. Поэтому можно делать так:

```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
    std::cout << &z - &y << "\n"; // 1
    std::cout << &z - &x << "\n"; // 2
    std::cout << &y - &x << "\n"; // 1
}
```

Еще один факт, указатели на тип размера `k` байт обязательно принимают значения адресов кратных `k`. Например, адреса `int` кратны 4.


Как видно `ptr1 - ptr2` это расстояние между указателями, но не в байтах. А в кол-ве переменных, которые между ними лежат.

Т.е. `ptr1 - ptr2` = `Расстояние в байтах` / `Рамер типа в байтах`

Отсюда понятно, как работает `ptr +- число`
```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    int* ptr = &z;
    std::cout << ptr << "\n"; // Адрес z
    std::cout << *ptr << "\n"; // 100
    std::cout << ptr - 1 << "\n"; // Адрес y
    std::cout << *(ptr - 1) << "\n"; // 3
    std::cout << ptr - 2 << "\n"; // Адрес x
    std::cout << *(ptr - 2) << "\n"; // 15
}
```

Также писать `ptr1 - ptr2` можно только для указателей одного типа:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_int - ptr_double << "\n"; // Тут CE
}
```

Тип `void*`

Как видно, независимо от типа указатель это адрес в памяти. Все указатели 64 - битны. Что если разработчик просто хочет хранить адрес без привязки к типу?

Для это есть `void*`
Но с ним несколько нюансов

```c++
#include <iostream>

int main() {
    int x = 15;
    void* ptr = &x; // В ptr лежит адрес x
    std::cout << ptr << "\n"; // Можно вывести адрес
    std::cout << ptr + 1 << "\n"; // Можно и так, но компилятор будет ругаться
    std::cout << *ptr << "\n"; // Так нельзя, void не содержит информацию о типе
    int* ptr_x = ptr; // Так тоже нельзя
}
```
Как мы уже обсудили, указатели разных типов несовместимы друг с другом. Вы можете преобразовывать указатель к `void*`. Но все остальные касты уже запрещены. 

Т.е. `void*` -> `int*`, `long long*` -> `double*` и т.п. Всё это уже писать нельзя, будет CE.

Но если очень хочется, то можно использовать `reinterpret_cast`, он как раз создан в том числе для таких случаев.

```c++
#include <iostream>

int main() {
    double x = 3.14;
    double* ptr = &x;
    long long* p = reinterpret_cast<long long*>(ptr);
    std::cout << *p;
}
```

Теперь `p` указывает на ту же область памяти, что и `ptr`. Но `p` считает, что там лежит `long long`, но на самом то деле там `double`. Поэтому разименовывая его мы получим число типа `long long`, с такими же битами, что и у числа `x`. Конечно, ничего хорошего от такого не стоит ожидать, но иногда это полезно.

Также стоит отметить следующее. Указатели это обычные переменные веса 8 байт. Значит, они лежат в памяти, как переменные. А значит, можно создать указатель на эту область памяти.
```c++
#include <iostream>

int main() {
    long long x = 3;
    long long* ptr = &x;
    long long** ptr_of_ptr = &ptr;
    std::cout << ptr << "\n " << ptr_of_ptr << "\n";
}
```
Указатель, это число в 16-ричном формате. Как получить само это число? Мы знаем, что оно весит 64 бита, причем беззнаковое. Т.е. это число типа unsigned long long.
Такой код адрес переводит в число:

```c++
#include <iostream>

int main() {
    int x = 5;
    void* ptr = &x;
    unsigned long long res = *reinterpret_cast<unsigned long long*>(&ptr);
    std::cout << ptr << "\n" << res << "\n";
}
```

Убедиться, что адреса типов размера k, действительно кратны k.


-------



# Динамическое выделение памяти

Все ваши данные в программе должны где-то храниться. До этого все переменные, что вы создавали, хранились в месте, которое называется `стек`. У него ограниченный размер, и его как раз и используют для локальных переменных. Еще есть область памяти, которая называется `heap(куча)`. По сути, это ваша оперативная память. Так вот она явно больше чем стек, и там очень часто аллоцируют данные большого размера

Для работы с кучей используют операторы `new` и `delete`

__`new` и `delete`__:

```c++
int* ptrx = new int; // Просим выделить память под переменую int
std::cout << ptrx << "\n";

double* ptry = new double(3.14); // Просим выделить память под переменую double, сразу приравниваем к 3.14
std::cout << ptry << "\n";
std::cout << *ptry << "\n";

delete ptrx; // Освобождаем запрошенную память
delete ptry;
```
Вывод
```
0x55fe5950eeb0
0x55fe5950f2e0
3.14
```

`new` возвращает указатель на память, где хранится ваша переменная. Можно сразу приравнять ей какое-то значение. Хорошей практикой является отдавать память, когда она вам больше не нужна. Для этого есть `delete`. После него пишите адрес, который вам когда-то вернул `new`. Освобождать память по какому-то адресу можно только один раз, дважды писать `delete` с одним и тем же указателем нельзя.

Также, помните, что `new` и `delete` -- дорогие операции, они работают достаточно долго.


## Указатели в классах

----


new, delete и деструктор

Наглядно, почему нужно писать `delete`, в таком коде деструктор не будет вызван, просто потому что объект не уничтожается

```c++
struct S {
    S() {
        std::cout << "S";
    }
    ~S() {
        std::cout << "~S";
    }
};

int main() {
    S* ptr = new S;
}
```

Вывод

```
S
```

А добавив `delete`

```c++
int main() {
    S* ptr = new S;
    delete ptr
}
```

Вывод

```
S~S
```


Теперь рассмотрим структуру `MemoryHolder`, которая выделяет память в своем конструкторе

```c++
struct MemoryHolder {
    S* ptr;
    MemoryHolder() {
        ptr = new S;
    }
};

int main() {
    MemoryHolder m;
}
```

Деструктор для нее мы не написали, поэтому вывод будет такой:

```
S
```
Т.е. снова мы не удалили выделенную память

Если добавить деструктор, то всё становится хорошо

