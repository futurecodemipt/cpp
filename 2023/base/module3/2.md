# Указатели 2

## Краткий план

```
Массивы как указатели
Способы передачи массива в функцию
operator new[]
operator delete[]
как передавать массивы в такие функции как sort, reverse, max_element
Связь между итераторами и указателями
```

## Уточнения по пунктам


```c++
int arr[5];
```

На самом деле, имя массива можно расценивать как указатель на его первый элемент.

```c++
std::cout << arr << "\n" << &arr[0]; // Выведет два одинаковых адреса
```

К указателям можно прибавлять числа и вычитать. Пусть указазатель `ptr` был типа `T*`, а размер у самого типа `T` равен `k` байт, тогда `ptr + 1` - это тоже указатель на область памяти, которая сдвинута на k байт.

Массив arr хранит свои элементы последовательно, поэтому для него, в частности, верно:

1. `&arr[0] + 1 == &arr[1]`
2. `&arr[1] + 1 == &arr[2]`
3. `&arr[2] + 1 == &arr[3]`

И так далее.

Более того:

1. `arr == &arr[0]`
2. `arr + 1 == &arr[0] + 1 == &arr[1]`
3. `arr + 2 == &arr[0] + 2 == &arr[2]`
4. `arr + 3 == &arr[0] + 3 == &arr[3]`

Т.е. на самом деле верно, что `arr + i` == `&arr[i]`


Как тогда работают `[]` при обращении к массиву?

`arr[number]  ===  *(arr + number)`

Но если имя массива -- это все равно что указатель на его первый элемент, т.е.

```c++
int* ptr = arr;
```

то можно сделать прямое соответствие между массивами и указателями:


```c++
int arr[5];
int* ptr = arr;
``` 

1. `*ptr  ===  ptr[0]  === arr[0]   ===  *arr`
2. `*(ptr + 1)  ===  ptr[1]  ===  arr[1]  ===  *(arr + 1)`
3. `*(ptr + 2)  ===  ptr[2]  ===  arr[2]  ===  *(arr + 2)`
4. `*(ptr + 3)  ===  ptr[3]  ===  arr[3]  ===  *(arr + 3)`
5. `*(ptr + 4)  ===  ptr[4]  ===  arr[4]  ===  *(arr + 4)`

И, в целом, для любого индекса `i` верно :

`*(ptr + i)  ===  ptr[i]  === arr[i]  ===  *(arr + i)`

Здесь `===` не оператор языка, а просто обозначие, что эти выражения -- одно и то же.

К слову, отсюда же следует синтаксический сахар:

`ptr[i] === *(ptr + i) === *(i + ptr) === i[ptr]`

Просьба так не писать.

# operator new[], delete[]


Классические массивы создаются на стеке.

Но можно создать и в `heap`.

Для этого используют `new[]`

```c++
int* arr = new int[5]; // Создали массив на 5 переменных
arr[0] = 1; // Индексация идет с 0
arr[1] = 2; // Чтобы обратиться к переменной, используют []
arr[2] = 4; // 3 число
arr[3] = 8; // 4 число
arr[4] = 16;// 5 число
for (int i = 0; i < 5; ++i) {
    std::cout << arr[i] << " ";
}
delete[] arr;
```

На самом деле, код отличается только в том, как мы создаем массив. Дальше вы с ним работаете, как с обычным массивом. Только теперь он создан в `heap`, а не на стеке. Как и раньше, хороший тон -- освободить память, но с массивами это делает `delete[]`

Также теперь уже можно создавать массивы с длиной не константа:

_Задача_:
Вводится число `n`. Затем `n` чисел. Нужно вывести эти числа в обратном порядке.
```c++
int n;
std::cin >> n;
int* goodArray = new int[n];
for (int i = 0; i < n; ++i) {
    std::cin >> goodArray[i];
}
for (int i = n - 1; i >= 0; --i) {
    std::cout << goodArray[i] << " ";
}
delete[] arr
```

Ввод:
```
5
1 2 4 8 16
```
Вывод:
```
16 8 4 2 1
```

## Связь итераторов и указателей

В начале пункта предлагается сказать, что итераторы вектора очень похожи на указатели.
По сути операции, которые они поддерживают, также поддерживают и указатели.
У итераторов вектора даже есть operator[](long long), который есть и у указателей.
Показать примеры того, как они похожи, в таком духе:

```c++
int n = 5;
int array[5] = {1, 2, 3, 4, 5};
auto first = array;
auto last = array + n;
while (first != last) {
    std::cout << *first << " ";
    ++first;
}
```

и

```c++
std::vector<int> vec = {1, 2, 3, 4, 5};
auto first = vec.begin();
auto last = vec.end();
while (first != last) {
    std::cout << *first << " ";
    ++first;
}
```

Дальше уже перейти к более общему описанию итераторов.

Итераторы - это концепт, некий паттерн программирования.
Указатели же в общем виде это элемент языка.
Однако как уже можно было заметить, итераторы похожи на указатели.

Выделяют несколько категорий итераторов, каждая следующая категория содержит критерии от предыдущей, примерное описание ниже:

* [forward_iterator](https://en.cppreference.com/w/cpp/iterator/forward_iterator)

Используя такие итераторы мы можем обходить контейнер лишь в одну сторону, причем увеличивать можем ровно на 1, засчет `оператора ++`. Как пример итераторы от `std::forward_list`.

* [bidirectional_iterator](https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator)

Такие итераторы позволяют обходить контейнер в любую сторону, но также лишь с шагом 1. Как пример итераторы от `std::list`, `std::set`, `std::map`.

* [random_access_iterator](https://en.cppreference.com/w/cpp/iterator/random_access_iterator)

Эти итераторы уже позволяют обходить контейнер с произвольным шагом. Как пример итераторы от `std::deque`.

* [contiguous_iterator](https://en.cppreference.com/w/cpp/iterator/contiguous_iterator)

Есть некая тонкость в отличии `contiguous_iterator` от `random_access_iterator`. Такие итераторы содержат все критерии на `random_access_iterator`, но обладают еще 1 свойством:

Пусть `iter1` и `iter2` - contiguous итераторы. Тогда должно быть верно следующее
`&(*iter2) = &(*iter1) + (iter2 - iter1)`.

Т.е. элементы под итераторами лежат последовательно в памяти. Это не верно для `std::deque`, но верно для `std::vector` и raw-pointers.

_На самом деле категорий итераторов чуть больше, но настолько глубоко копать не будем, тк не сможем дать простой пример, зачем это нужно_.

Ссылки тут даны лишь как официальная справка, и детям такое читать не стоит. Просто рассказать на пальцах про эти категории(но можно конечно и показать на свой страх и риск).

------------------

Предлагается рассмотреть следующие примеры:

Пусть даны контейнеры

```c++
int n = 5;
std::vector<int> vec = {1, 2, 3, 4, 5};
int array[5] = {1, 2, 3, 4, 5};
std::deque<int> dq = {1, 2, 3, 4, 5};
std::list<int> lst = {1, 2, 3, 4, 5};
std::forward_list<int> flst = {1, 2, 3, 4, 5};
```

CE, т.к. нужен хотя бы `random_access_iterator`:

```c++
std::sort(array, array + 5);
std::sort(vec.begin(), vec.end());
std::sort(dq.begin(), dq.end());
std::sort(lst.begin(), lst.end()); // CE
std::sort(flst.begin(), flst.end()); // CE

std::random_shuffle(array, array + 5);
std::random_shuffle(vec.begin(), vec.end());
std::random_shuffle(dq.begin(), dq.end());
std::random_shuffle(lst.begin(), lst.end()); // CE
std::random_shuffle(flst.begin(), flst.end()); // CE
```

CE, т.к. нужен хотя бы `bidirectional_iterator`:

```c++
std::reverse(array, array + 5);
std::reverse(vec.begin(), vec.end());
std::reverse(dq.begin(), dq.end());
std::reverse(lst.begin(), lst.end());
std::reverse(flst.begin(), flst.end()); // CE
```

CE нигде нет, нужен хотя бы `forward_iterator`, а все они таковыми являются.

```c++
std::max_element(array, array + 5);
std::max_element(vec.begin(), vec.end());
std::max_element(dq.begin(), dq.end());
std::max_element(lst.begin(), lst.end());
std::max_element(flst.begin(), flst.end());
```

Также стоит отметить, что это не все требования на итераторы, например, итераторы `std::set` в некоторых функциях тоже дадут CE из-за своей immutable природы. (мы не можем делать swap, имея только итераторы std::set, а он нужен в некоторых функциях из std).


