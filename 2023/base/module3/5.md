std::vector
=====

Этот урок посвящен вектору из std. Он состоит из двух частей.

1. Показать, как std::vector работает с памятью сам
2. Написать свою упрощенную версию


--------------------------------

Предлагается написать такую стуктуру, рассказать про буфер, в котором хранятся наши данные.

```c++
struct S {
    int x;
    S() : x(0) {
        std::cout << "default " << x << "\n";
    }
    S(int x) : x(x) {
        std::cout << "constructor " << x << "\n";
    }
    S(const S& another) : x(another.x) {
        std::cout << "copy from " << x << "\n";
    }
    S& operator=(const S& another) {
        std::cout << x << " = from " << another.x << "\n";
        x = another.x;
        return *this;
    }
    ~S() {
        std::cout << "destroy " << x << "\n";
    }
};
```

А дальше использовать `std::vector<S>` и смотреть на вывод.

Интересуют следующие примеры:


Вызывается дефолтный у 3 элементов.

```c++
std::vector<S> vec(3);
```

Вызывается copy у 3 элементов

```c++
std::vector<S> vec(3, S(5));
```

Тут пример, когда вектор перевыделяет память.

```c++
std::vector<S> vec(2);
vec.push_back(S(16)); // <----- интересует
```

Пример, что вызывается деструктор

```c++
std::vector<S> vec(2);
vec.push_back(S(16));
vec.pop_back(); // <----- интересует
```

Более сложный пример с перевыделением.

```c++
std::vector<S> vec(2);
std::cout << "-----------\n";
vec.push_back(S(1)); // <----- интересует
std::cout << "-----------\n";
vec.push_back(S(2)); // <----- интересует
std::cout << "----------\n";
vec.push_back(S(3)); // <----- интересует
std::cout << "-----------\n";
vec.push_back(S(4)); // <----- интересует
```

resize вызывает деструктор, но память не освобождает

```c++
std::vector<S> vec(2);
vec.resize(0); // <----- интересует
std::cout << vec.size() << " " << vec.capacity();
```

reserve выделяет память, но не создает новых объектов.

```c++
std::vector<S> vec(2);
vec.recerve(10); // <----- интересует
std::cout << vec.size() << " " << vec.capacity();
```

вызывается copy

```c++
std::vector<S> vec(4);
for (int i = 0; i < 4; ++i) {
    vec[i].x = i;
}
std::cout << "--------\n";
std::vector<S> another = vec; // <----- интересует
std::cout << "---------\n";
```


---------------

Очень важный пример, вызывается operator= у первых двух, а у других destroy

```c++
std::vector<S> vec(4);
for (int i = 0; i < 4; ++i) {
    vec[i].x = i;
}
std::cout << "--------\n";
std::vector<S> vec2(2);
for (int i = 0; i < 2; ++i) {
    vec2[i].x = i + 4;
}
std::cout << "--------\n";
vec = vec2; // <----- интересует
std::cout << "---------\n";
```


А если поменять местами vec и vec2, то вызовется destroy у старых и copy для новых

```c++
std::vector<S> vec(4);
for (int i = 0; i < 4; ++i) {
    vec[i].x = i;
}
std::cout << "--------\n";
std::vector<S> vec2(2);
for (int i = 0; i < 2; ++i) {
    vec2[i].x = i + 4;
}
std::cout << "--------\n";
vec2 = vec; // <----- интересует
std::cout << "---------\n";
```

Почему так? В operator= есть несколько вариантов

1. Память нужно выделять заново, тк новый вектор слишком большой и в память не поместиться. Тогда старые удаляются, выделяется новая память, и туда копируются элементы нового вектора
2. Памяти хватит, чтобы поместить новый вектор. Тогда для тех элементов, которые там уже лежат, будет вызван operator=, если новый вектор больше, то для новых элементов будет сделан copy, а если новый вектор меньше, то лишние элементы будут destroy.

Еще пример для пункта 2

```c++
std::vector<S> vec(1);
vec[0] = 1;
vec.reserve(10);
std::cout << "--------\n";
std::vector<S> vec2(5);
for (int i = 0; i < 5; ++i) {
    vec2[i].x = i + 2;
}
std::cout << "--------\n";
vec = vec2; // <----- интересует
std::cout << "---------\n";
```

Будет часть с 
```
1 = from 2
copy from 3
copy from 4
copy from 5
copy from 6
```
Она как раз про текст выше.

-----------------------

После обсуждения текста выше предлагается начать писать свой вектор. Задача есть в контесте.

Скорее всего, самая простая последовательность написания такая:

1. Конструкторы обычные
2. push_back
3. pop_back
4. resize, reserve, shrink_to_fit
5. size ...
6. констуктор копирования
7. operator =

Пункт 1 - говорим, как храним данные. Пользуемся аллокатором для выделения памяти. Обращаем внимание, что конструкторы при выделении не вызываются для всех выделенных элементов, а только для тех, которые попросили создать.

Пункт 2 - показываем, что память надо перевыделять, увеличивая в 2 раза.

Пункт 3 - что нужно вызывать деструктор, а не просто уменьшать размер

Пункт 4 - тут нужно будет сделать общие функции для перевыделения памяти, если еще не сделали. Иначе будет много копипасты.

Пункт 5 - все методы для чтения состояния, size, operator[], capacity. Отдых перед пунктами 6 и 7

Пункт 6 - потребуются функции для заполнения памяти значениями, если еще не написали. Иначе копипаста

Пункт 7 - показывает, поняли ли вектор или нет. Описание работы дано выше.

После пункта 7 можно выдохнуть, вектор написан.

_Вектор выше немного отличается от std::vector, но эта реализация на несколько шагов впереди от того, что обычно могут написать люди(даже знающие язык). От полного вектора нас отделяют(самое крупное) move-семантика, исключения, итераторы и специализация для типа bool._

