__Ссылки__

Рассказать про обычные и немного про константные ссылки.

На начальном уровне детям можно объяснить, что ссылка на переменную `x`, это та же переменная `x`, только с другим именем. В будущих уроках будет показано, что это не совсем так.
```c++
#include <iostream>

int main() {
    int x = 5;
    int& y = x; // y -- ссылка на x
    std::cout << x << " " << y; // 5 5
    x += 1;
    std::cout << x << " " << y; // 6 6
    y += 1;
    std::cout << x << " " << y; // 7 7
}
```
Теперь `x` и `y` для нас одно и то же.

```c++
#include <iostream>

int main() {
    int x = 5;
    int& y; // CE, так нельзя, ссылка должна ссылаться на что-то
    int& z = 5; // CE, так тоже нельзя, ссылка должна ссылаться на переменную
}
```

Константные ссылки
```c++
#include <iostream>

int main() {
    int x = 5;
    const int& z; // CE, так нельзя, константная ссылка должна ссылаться на что-то
    const int& y = 6; // А вот так уже можно
    std::cout << y << "\n";
    const int& t = x;
    std::cout << x << " " << t << "\n";
    x += 1; // Так можно
    std::cout << x << " " << t << "\n";
    t += 1; // Так нельзя, ведь t - КОНСТАНТНАЯ ссылка
    std::cout << x << " " << t << "\n";
}
```

Стоит отметить, что сама ссылка, как объект, весит 8 байт.

Пока ссылки для нас это просто способ передавать аргументы в функции так, чтобы переменные не копировались.


```c++
void f(std::vector<int> x) { // долго и дорого
}

void g(std::vector<int>& x) { // быстро
}

void h(const std::vector<int>& x) { // быстро и универсально
}

int main() {
    const int N = 1000000;
    std::vector<int> vec(N);
    f(vec); // Будет создана копия
    g(vec); // Будет копия не будет создана
    р(vec); // Копия также не будет создана
}
```

```c++
void f(double x) { 
}

void g(double& x) {
}

void h(const double& x) {
}

int main() {
    double var = 0.5;
    f(var); // Будет создана копия
    g(var); // Копия не будет создана
    р(var); // Копия также не будет создана

    g(1.5); // Здесь будет ошибка компиляции
    р(1.5); // А здесь ее не будет
}
```




## Одинаковые имена у функций

Эта часть называется перегрузка функций.

Вы действительно можете давать одинаковые имена вашим функциям

```c++
void f(int x) {
    std::cout << "int\n";
}

void f(double x) {
    std::cout << "double\n";
}

int main() {
    int a = 5;
    double b = 0.1;
    f(a);
    f(b);
}
```

Вывод:

```
int
double
```

На самом деле, функция определяется не именем, а именем + её аргументами, а именно их типами.

В примере написано 2 функции, `f(int)` и `f(double)`, а не одна.

Тогда как выбирается функция, которую вызвать?

Сначала, естественно, смотрится имя функции, которую вы написали.

А после этого смотрится, какие типы аргументов вы передали, и исходя из этого подбирается нужная версия функции.

В примере, вы оба раза вызываете функцию `f`, но первый раз передаете `a`, который `int`. Во второй раз вы передаете `b`, который `double`. Поэтому в первый раз вызвалась `f(int)`, а во второй -- `f(double)`. Порядок вызовов можно посмотреть в поле `Вывод`.

Еще пример:

```c++
int myMax(int x, int y) {
    return x > y ? x : y;
}

double myMax(double x, double y) {
    return x > y ? x : y;
}

long long myMax(long long x, long long y) {
    return x > y ? x : y;
}

char myMax(char x, char y) {
    return x > y ? x : y;
}
```

Эта функция возвращает максимум из двух данных чисел. В качестве агрументов вы можете передавать переменные любых типов, которые написаны в функциях.

Но что произойдет, если вы передаете в функцию переменную такого типа, которого нет в аргументах функции, т.е.:

```c++
void f(int x) {

}

int main() {
    double a = 0.3;
    f(a);
}
```

Правильно, в таком примере произойдет приведение типов. `double` будет кастоваться в `int`

Всё не так очевидно, если у `f` есть несколько версий. Например:

```c++
void f(int x) {
    std::cout << "int";
}

void f(long long x) {
    std::cout << "long long";
}

int main() {
    double a = 0.3;
    f(a);
}
```

Такая программа не скопилируется, просто потому что компилятор не знает, какую версию функциии выбрать. Ему одинаково плохо переводить `double` что в `int`, что в `long long`. Поэтому он предпочитает не выбирать и просто не компилировать такой код.

Даже такой пример не скомпилируется:

```c++
void f(int x) {
    std::cout << "int";
}

void f(long long x) {
    std::cout << "long long";
}

void f(float x) {
    std::cout << "long long";
}

int main() {
    double a = 0.3;
    f(a);
}
```

Все 3 варианта компилятор расценивает как одинаково плохие.

Подведем итог, как выбирается функция `f`

Все реализации функции сортируются компилятором по тому, насколько хорошо они подходят. После этого берется лучший вариант. Но если таких вариантов несколько, то происходит ошибка `ambigious call`, это `CE`


Также, для выбора версии функции нет никакой разницы, ссылочный ли тип у аргумента или нет. Для него в следующем коде объявлено две одинаковые функции

```c++
void f(long long x) {
    std::cout << "long long";
}

void f(long long& x) {
    std::cout << "long long&";
}

int main() {
    long long a = 404;
    f(a);
}
```
Причем, если закомментировать строчку с `f(a);`, то код уже будет компилироваться.

# Рекурсия

Когда вы пишите функции, вы можете в теле функции вызывать эту же функцию. Такие ситуции называют рекурсией:
```c++
int f(int x) {
    f(x);
}
```
Каждый раз, `f` будет вызываться заново. В данном примере, это будет происходит бесконечно, т.е. ваша программа зациклится. Но на самом деле, прямо бесконечно она работать не будет. Это связано с тем, что вызывая функцию, на стек кладятся её адрес, он весит `8 байт`, а как мы помним, у стека не очень большой размер. Поэтому рано или поздно, стек у вас переполнится, и будет ошибка `stack overflow`. Это `runtime error` (RE). Кстати, так называется один очень известный сайт для программистов, рано или поздно вы с ним точно столкнетесь)

Поэтому, если возникла неободимость писать рекурсию, первое, о чем вы должны подумать, это как недопустить бесконечную рекурсию.

Рассмотрим задачу.

_Задача1_:

Числа Фибонначи, это последовательность 1, 1, 2, 3, 5, 8, 11...

Каждое следующее число, это сумма двух предыдущих.

Формально

1. $F_1$ = 1
2. $F_2$ = 1
3. $F_n$ = $F_{n-1}$ + $F_{N - 2}$, при $n > 2$

Дано число $n$. Вывести $F_n$

_Решение_:

Здесь нам и пригодится рекурсия:

Посмотрим на функцию:

```c++
int fibo(int n) {
    return fibo(n - 1) + fibo(n - 2);
}
```

Это почти правильная функция, но в ней нет условий остановки рекурсии, она по-прежнему бесконечная

```c++
int fibo(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    return fibo(n - 1) + fibo(n - 2);
}
```

Теперь условия остановки есть, функция будет работать

_Код_:
```c++
for (int i = 1; i <= 10; ++i) {
    std::cout << "F" << i << " = " << fibo(i) << "\n";
}
```

_Вывод_:
```
F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
```

Заметим, что если написать `fibo(0)`, то мы снова получим бесконечную рекурсию, тк такие ситуации у нас не обрабатваются. Поэтому тут вы либо предполагаете, что у вас не вызывают функцию от аргументов $n < 1$, либо добавляете это в точки остановки.

В целом, старайтесь избегать рекурсию, тк она медленнее, чем аналогичная программа без неё. Хотя, конечно, есть задачи, в которых без рекурсии не справиться.


