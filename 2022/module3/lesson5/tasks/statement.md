# Философы

`N` безмолвных философов сидят вокруг круглого стола, перед каждым философом стоит тарелка спагетти. Вилки лежат на столе между каждой парой ближайших философов.

Каждый философ может либо есть, либо размышлять. Приём пищи не ограничен количеством оставшихся спагетти — подразумевается бесконечный запас. Тем не менее, философ может есть только тогда, когда держит две вилки — взятую справа и слева 

Каждый философ может взять ближайшую вилку (если она доступна) или положить — если он уже держит её. Взятие каждой вилки и возвращение её на стол являются раздельными действиями, которые должны выполняться одно за другим.

## Задача

Опишите логику поведения поведения философов. А именно, как им следует брать вилки и как убирать(в каком порядке).

Класс вилка задается таким образом:
```c++
class Fork {
public:
    void TakeFork();
    void RemoveFork();
    int GetNumber() const;
};
```

Объект вилка -- уникальный объект, со своим собственным номером.
Вилку можно взять, а можно положить.

Метод `TakeFork` попытается завладеть вилкой. Но если какой-то из философов ей уже завладел, то метод будет ждать, пока он ее не уберет. А именно, пока он не вызовет `RemoveFork`.

Метод `RemoveFork` вызывают, когда вилку нужно вернуть на стол. Вилка должна быть кем-то взята, иначе UB.

Класс Философ задается следующим образом:

```c++
class Philosopher {
    Fork& LeftFork;
    Fork& RightFork;
public:
    Philosopher(Fork& left, Fork& right) : LeftFork(left), RightFork(right) {};

    void TakeAllForks() {
        // YOUR CODE HERE
    }

    void RemoveAllForks() {
        // YOUR CODE HERE
    }
};

```

Допишите методы `TakeAllForks` и `RemoveAllForks`.

Результат вызова `TakeAllForks` -- все 2 вилки у данного философа.

Результат вызова `RemoveAllForks` -- все 2 вилки, что были у философа, он положил на стол/

## Тестирующая система

Реализация класса `Fork` будет подключена к вашему коду.

Тестирующая система будет заставлять философов есть в таком виде:

```c++
void MakePhilosopherEat(Philosopher& philosopher) {
    philosopher.TakeAllForks();
    philosopher.RemoveAllForks();
}
```

Т.е., чтобы поесть, философ должен сначала взять все вилки, а затем положить на место.

Будет создано `N` потоков, каждый для отдельного филисофа. И в каждом этом потоке философ должен будет поесть `M` раз. (`M` вызовов `MakePhilosopherEat`). 

`N` и `M` не раскрываются, тк запусков тестов будет несколько. В систему отправляйте лишь код класса `Philosopher`


