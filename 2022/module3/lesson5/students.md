## Потоки

Многопоточное программирование в С++ - это способность программы выполнять несколько задач одновременно, используя несколько потоков. Поток - это легковесный процесс, который может выполняться параллельно с другими потоками в рамках одного процесса. Многопоточное программирование позволяет увеличить производительность и эффективность программы, особенно при работе с большими объемами данных или при выполнении задач, которые могут быть разбиты на независимые подзадачи. Однако, многопоточное программирование также может привести к проблемам синхронизации и конкуренции за ресурсы, поэтому требует особого внимания при проектировании и реализации.



Можно считать, что поток - это просто функция, которая выполняется асинхронно относительно оригинальной программы. Т.е. параллельно.

Однажды создав поток, у него нужно либо вызвать метод

`join()` -- будет дожидаться, пока поток польностью не отработает, и только после этого продолжит работу

`detach()` - отпустит поток, т.е. теперь он абсолютно независим от текущей программы.

Для работы с потоками есть класс `std::thread`.

В конструкторе класса нужно передавать функцию, которую необходимо запустить параллельно. Если у функции есть аргументы, то их передают после самой функции через запятую.

Пример использования `thread` в С++:

```c++
#include <iostream>
#include <thread>

void printMessage(const std::string& message) {
    std::cout << "Thread ID: " << std::this_thread::get_id() << "\n";
    std::cout << message << "\n";
}

int main() {
    std::thread t1(printMessage, "Hello from thread 1!");
    std::thread t2(printMessage, "Hello from thread 2!");

    t1.join();
    t2.join();
}
```

В этом примере мы создаем два потока, каждый из которых вызывает функцию `printMessage` с разными аргументами. Функция выводит сообщение и идентификатор потока, используя метод `std::this_thread::get_id()`. Затем мы ждем, пока оба потока завершатся, используя метод `join()`.

## Race condition

Race condition - это ситуация, когда результат выполнения программы зависит от того, какой поток выполнится первым, а какой вторым. В многопоточных программах race condition может возникнуть, если два или более потоков пытаются одновременно получить доступ к общему ресурсу (например, переменной), изменять его значение и записывать обратно. Если не использовать механизмы синхронизации, такие как mutex, то результат может быть неожиданным и непредсказуемым.

Предположим, у нас есть два потока, которые работают с одной переменной x:

```
Поток 1:
x = x + 1;
```

```
Поток 2:
x = x + 1;
```

Если оба потока начинают работу одновременно, то может возникнуть race condition. Например, если значение x изначально равно 0, то оба потока могут прочитать это значение, добавить к нему 1 и записать обратно значение 1. В этом случае мы ожидали, что значение x будет равно 2, но на самом деле оно будет равно 1. Это произошло потому, что оба потока работали с переменной одновременно и не было никакой синхронизации между ними.

Race condition может быть решен путем синхронизации доступа к общим ресурсам, таким как переменные, файлы и т.д. Существует несколько способов синхронизации:

1. Мьютексы: это механизм синхронизации, который позволяет блокировать доступ к общему ресурсу до тех пор, пока его не освободит другой поток.

2. Семафоры: это механизм синхронизации, который позволяет ограничить количество потоков, которые могут одновременно получить доступ к общему ресурсу.

3. Критические секции: это механизм синхронизации, который позволяет блокировать доступ к общему ресурсу только для одного потока в определенный момент времени.

4. Атомарные операции: это специальные операции, которые гарантируют, что операция будет выполнена целиком и никакой другой поток не сможет изменить значение в промежутке между чтением и записью.

В зависимости от конкретной ситуации и языка программирования можно выбрать подходящий механизм синхронизации. Главное, чтобы он гарантировал правильное выполнение операций над общими ресурсами и предотвращал race condition.

## Mutex

Mutex (сокращение от mutual exclusion - взаимное исключение) - это механизм синхронизации, который позволяет разделять доступ к общим ресурсам между несколькими потоками. Mutex гарантирует, что только один поток может получить доступ к защищенному ресурсу в определенный момент времени. Если другой поток попытается получить доступ к ресурсу, пока он заблокирован другим потоком, он будет ожидать, пока ресурс не будет освобожден. `Mutex` используется для предотвращения состояния гонки и других проблем, связанных с параллельным выполнением кода несколькими потоками.

Пример использования mutex в С++:

```c++
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx; // создание объекта mutex

void printNumbers(int num) {
    mtx.lock(); // блокировка доступа к ресурсу
    for (int i = 1; i <= num; i++) {
        std::cout << i << " ";
    }
    std::cout << std::endl;
    mtx.unlock(); // разблокировка доступа к ресурсу
}

int main() {
    std::thread t1(printNumbers, 5);
    std::thread t2(printNumbers, 10);
    t1.join();
    t2.join();
}
```

В этом примере два потока `t1` и `t2` вызывают функцию `printNumbers`, которая выводит числа от 1 до заданного числа `num`. При этом доступ к стандартному выводу (ресурсу) блокируется с помощью объекта mutex mtx, чтобы избежать конфликтов при параллельном доступе к нему. Каждый поток блокирует доступ к ресурсу перед выводом чисел и разблокирует его после окончания вывода.

## Атомарные операции

Атомарная операция - это операция, которая выполняется целиком и неделима, то есть другой поток не может изменить значение переменной в процессе выполнения этой операции. Атомарные операции гарантируют, что значение переменной будет корректным и не будет возникать race condition. Некоторые языки программирования предоставляют встроенные атомарные операции, например, операцию инкремента или декремента. В других языках программирования атомарные операции могут быть реализованы с помощью мьютексов или других механизмов синхронизации.

В C++11 и выше, класс std::atomic<T> предоставляет атомарные операции для различных типов данных, например:

1. std::atomic<int> - атомарная переменная типа int.
2. std::atomic<bool> - атомарная переменная типа bool.
3. std::atomic<double> - атомарная переменная типа double.

Рассмотрим пример:

Без atomic:

```c++
int counter;
void increment() {
    for (int j = 0; j < 10000; ++j) {
        counter += 1;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    std::thread t3(increment);
    std::thread t4(increment);
    std::thread t5(increment);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();
    std::cout << counter;
}
```
Вывод:
```
20088
```

Должны были получить 50000, но получили меньше, как раз из-за `race condition`

С atomic:

```c++
std::atomic<int> counter;
void increment() {
    for (int j = 0; j < 10000; ++j) {
        counter += 1;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    std::thread t3(increment);
    std::thread t4(increment);
    std::thread t5(increment);
    t1.join();
    t2.join();
    t3.join();
    t4.join();
    t5.join();
    std::cout << counter;
}
```


В этом примере создается атомарная переменная counter типа `int` и инкрементируется в нескольких потоках с помощью оператора `++`. Атомарность операции гарантирует, что значение счетчика будет корректным, даже если несколько потоков пытаются изменить его одновременно.

Того же функционала можно добиться с помощью `mutex`, однако в этом случае `atomic` намного быстрее

Стоить заметить, что во-первых атомарные переменные используются только для числовых типов, а во-вторых, у них довольно много специфичных и сложных методов. Этот примитив синхронизации довольно низкоуровневый и используется как фундамент для многих других примитивов. 

## Futures

Допустим, вы хотите посчитать определенную величину асинхронно, для этого вы пишите фукнцию и создаете поток, который бы ее исполнил

```c++
long long calculateSomeThingHard(long long number) {
    long long res = 0;
    for (long long i = 0; i < number; ++i) {
        res += i;
    }
    return res;
}

int main() {
    std::thread t1(calculateSomeThingHard, 100);
    t1.join();
}
```

Однако, как получить возвращаемое значение?

`Future` в C++ - это объект, который представляет собой результат асинхронной операции. Он позволяет получить результат выполнения задачи, которая может выполняться в другом потоке или даже на другом компьютере.


```c++
long long calculateSomeThingHard(long long number) {
    long long res = 0;
    for (long long i = 0; i < number; ++i) {
        res += i;
    }
    return res;
}

int main() {
    auto future = std::async(calculateSomeThingHard, 10000000);
    std::future<long long> simple = future.get();
    std::cout <<  simple;
}
```

В этом примере используется функция std::async. Она асинхронно запускает выполнение кода, возвращает `future` на результат и передает контекст текущей программе.
Однако вызов метода `get` заставит программу ждать, пока результат не будет подсчитан.

Подобные механизмы зачастую можно встретить во многих других языках, например java script.