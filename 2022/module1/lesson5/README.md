1.5 Функции. Время жизни переменных
=============



# Функции

Представьте, вы пишите один и тот же код несколько раз, у него одна и та же логика, поэтому вы бы хотели написать его один раз, а потом как-то использовать готовый. Или же вы разработчик библиотеки, придумали интересное решение задачи, и хотите чтобы другие люди пользовались вашим решением. Но как реализовать какой-то код отдельно от вашей программы?

Для этого есть функции.

Все вы уже сталкивались с ними хотя бы однажды. Просто когда писали функцию `main`. 

В математике есть функция квадратный корень. Она принимает `1 число`(опустим, что оно должно быть >= 0). Возвращает она также `одно число`. Функция называется `Квадратный корень`, на английском пусть `sqrt`. 

Или же, рассмотрим функцию $f(x, y, z) = x * y * z$ Это функция возращает число, принимает 3 числа, а называется `f`.

Функции в программировании имеют похожую логику.

Синтаксис такой:

```
ТипВозвращаемогоЗначения Имя(Тип1 Аргумент1, Тип2 Аргумент2, ..., ТипN АргументN) {
}
```

Давайте напишем $f(x, y, z) = x * y * z$


```c++
int f(int x, int y, int z) {
    return x * y * z;
}
```

На первое место ставится, какой тип будет возвращать функция. Потом идет её имя. В скобках указано, от каких аргументов зависит функция. А также слово `return`. Функция вернет ровно то значение, которое там написано.

Применение:
```c++
int x = 5;
int y = 2;
int z = 10;
int res = f(x, y, z);
std::cout << res; // Выведет 100
```
Т.е. в целом, вы можете считать, что вместо надписи выполняется код внутри функции, а результат надписи, это то, что написано в коде после `return`. Хотя, это не совсем описывает то, что происходит на самом деле.

Функции нужно писать снаружи `main`. После всех `#include`

```c++
#include <iostream>

int f(int x, int y, int z) {
    return x * y * z;
}

int main() {
    int x = 5;
    int y = 2;
    int z = 10;
    int res = f(x, y, z);
    std::cout << res; // Выведет 100
}
```

Любая функция, которая имеет возвращаемое значение, должна иметь слово `return` в конце. Если его `не написать`, то будет неопределенное поведение(UB - undefined behaviour). Это означает, что ваш код потенциально `может упасть`, такая ситуация называется RE(runtime-error). А `может и не успать`. Поэтому и называется неопределенное поведение.

Единственное исключение -- функция `main`. По дефолту, считается, что `main` возвращет код ошибки, которая в ней произошла, и 0 -- если ошибки не было. Поэтому иногда можно встретить, как в конце `main` пишут `return 0;`.

Отметим, что в большей части компиляторов можно это и не писать, тк `main` автоматически возвращает `0`. Поэтому в методичке почти всегда в `main` не стоит никаких `return`

Рассмотрим еще функцию, назовем её `degree`. Она принимает 2 числа: вещественное `number` и целое `step` - степень. Она возвращает $number^{step}$. Т.е. возводит число в степень.

```c++
double degree(double number, int step) {
    double result = 1;
    for (int i = 0; i < step; ++i) {
        result *= number;
    }
    return result;
}
```
Применение:
```c++
std::cout << degree(5, 2); // Будет 25
double a = 3;
int s = 3;
std::cout << degree(a, s); // Будет 27
```

У этой функции есть эквивалент, он лежит в `#include <cmath>` и называется `std::pow`.

Также функция в целом не обязана возвращать какое-либо значение, пример:

```c++
void f(int x) {
    std::cout << x << " " << x + 1 << "\n";
}
```
Эта функция выводит на экран 2 последовательных числа и ничего не возвращает. В таком случае в возвращаемом значении функции пишут `void`. И в конце не ставят никакого `return`. Хотя, в целом, можно и поставить, но это не имеет смысла

```c++
void f(int x) {
    std::cout << x << " " << x + 1 << "\n";
    return;
}
```


Использование
```c++
int main() {
    f(0); // Выведет на экран 0 1
    f(5); // Выведет на экран 5 6
}
```

Как видите, в функциях можно писать любой код, который вы до этого писали, в том числе объявлять новые переменные, писать циклы, вызывать другие функции и т.п.

Конечно, здесь очень(ОЧЕНЬ) много подводных камней, и несколько из них мы рассмотрим.

1. Многие в начале заблуждаются с именами аргументов.

Но источник этой проблемы лежит в понятии `Область видимости переменной`.

Отдельно про это понятие:

Область видимости -- это грубо говоря, те строчки кода, где вы можете обращаться к переменной.


Вот несколько примеров, с пояснением, на каких строчках какие переменные видны. Примеры будут усложнятся:
_Пример1_:
```c++
void func() {
    // Тут не виден x
    // x = 6; // Если раскомментировать строчку, то будет ошибка компиляции(CE)
    // Тут не виден x
}

int main() {
    int x = 5;
    // Тут виден x
    // Тут виден x
    // Тут виден x
}
```
_Пример2_:
```c++
void func() {
    // Тут не виден x, не виден y
    // Тут не виден x, не виден y
}

int main() {
    int x = 5;
    // Тут виден x, не виден y
    if (x == 0) {
        int y = 6;
        // Тут виден x, виден y
        // Тут виден x, виден y
    }
    // Тут виден x, не виден y
    // Тут виден x, не виден y
}
```

В целом область видимости можно создавать с помощью `{}`:

_Пример3_:
```c++
void func() {
    // Тут не виден x, не виден y
    // Тут не виден x, не виден y
}

int main() {
    int x = 5;
    // Тут виден x, не виден y
    { // Да, так можно писать
        int y = 6;
        // Тут виден x, виден y
        // Тут виден x, виден y
    }
    // Тут виден x, не виден y
    // Тут виден x, не виден y
}
```

_Пример4_:

```c++
void func(int a) {
    // Тут не виден x, виден a
    // Тут не виден x, виден a
}

int main() {
    int x = 5;
    // Тут виден x, не виден a
    f(x);
    // Тут виден x, не виден a
}
```
`int a ` в аргументах функции -- это отдельная переменная, она не совпадает с `x`. В частности, если написать так:

_Пример5_:
```c++
#include <iostream>

void func(int a) {
    a = 0;
}

int main() {
    int x = 5;
    std::cout << x << "\n"; // Выведет 5
    f(x);
    std::cout << x << "\n"; // Выведет 5
}
```
Как видите `x` в `main` не поменялся. В том числе, если вы назовете аргумент в функции `func` тоже `x`, поведение не изменится.

_Пример6_:

```c++
#include <iostream>

void func(int x) {
    x = 0;
}

int main() {
    int x = 5;
    std::cout << x << "\n"; // Выведет 5
    f(x);
    std::cout << x << "\n"; // Выведет 5
}
```

Повторим, переменные в аргументах, это отдельные переменные, которые существуют только в рамках функции. Они не зависят от названий других переменных `main` или других функций. Доступ происходит именно по тому, где находится переменная, а не по названию.

И всё это из-за области видимости.

При этом вы не можете создать 2 переменные с одинаковым названием в одной и той же области видимости, но можете -- в разных.

А именно:

_Пример7_:

```c++
int main() {
    int x = 5;
    int x = 6; // Так нельзя, x уже объявлена
}
```


_Пример8_:
```c++
#include <iostream>

int main() {
    int x = 5;
    std::cout << x << "\n"; // Выведет 5

    {
        int x = 0; // Так можно, это новая область видимости
        std::cout << x << "\n"; // Выведет 0
    }

    std::cout << x << "\n"; // Выведет 5
}
```

Когда вы во второй раз объявляете переменную `x`, вы создаете её в новой области видимости. Теперь старая `x` вам недоступна. Поэтому можно создать вторую `x`, и внутри фигурных скобок будет изменяться именно новая переменная, старая никак не будет затронута.

На самом деле _Пример6_ и _Пример8_ эквивалентны, просто посмотрите на них еще раз.

Отсюда вывод: `Старайтесь не называть переменные одинаковым именем, чтобы не путаться`

И последнее про область видимости - это глобальные переменные.

Переменные можно объявлять и вне `main`.  Тогда их область видимости -- весь код. 

```c++
#include <iostream>

int globalVar = 1;

void func() {
    // Тут виден globalVar
    globalVar = 5;
}

int main() {
    // Тут виден globalVar
    std::cout << globalVar << "\n"; // Выведет 1
    func();
    std::cout << globalVar << "\n"; // Выведет 5
}
```

Такие переменные называются глобальные, и они создаются на этапе компиляции. Более того, если изначально не инициализировать их, то в них будет храниться дефолтное значение типа. Для всех числовых типов это 0

```c++
#include <iostream>

int globalVar;

int main() {
    std::cout << globalVar << "\n"; // Выведет 0
    int x;
    std::cout << x << "\n"; // Так нельзя, локальные переменные вы обязаны инициализировать
}
```

Глобальные переменные хранятся не на стеке, не на куче(`heap`), а в специальной области памяти. Более того, тк они создаются на этапе компиляции, с помощью них, например, создавать статические массивы намного быстрее, чем локально:

```c++
#include <iostream>

int a[10]; // Создан при компиляции, 0 миллисекунд

int main() {
    int b[10]; // Создан во время работы, сколько-то миллисекунд
}
```

```c++
#include <iostream>

int a[1000000]; // Создан при компиляции, 0 мс

int main() {
    int b[1000000]; // Создан во время работы, много мс
    // Более того, скорее всего программа УПАДЕТ, тк миллион интов не поместится на стек,
    // ведь стек -- маленький
}
```

__Поэтому, если вы решили создать большой массив, то либо создавайте его глобально, либо используйте `new[]`, либо используйте `std::vector`__

Вернемся к функциям

2. `return` можно писать несколько раз

```c++
#include <cmath>

double safeSqrt(double x) {
    if (x < 0) {
        return 0;
    }
    double ans = std::sqrt(x);
    return ans;
}
```
Когда ваш код доходит до слова `return`, выполнение функции прерывается и возращается значение, указанное в `return`

Функция в примере, если $x < 0$, вовращает 0, иначе возвращает квадратный корень из `x`

```c++
#include <cmath>
#include <iostream>

void check(int x) {
    if (x < 0) {
        std::cout << "less then zero\n";
        return;
    }
    if (x == 0) {
        std::cout << "zero\n";
        return;
    }
    std::cout << "more then zero" << "\n";
}
```

Эта функция выводит, меньше нуля, равно нулю или больше чем нуль, заданное число `x`. Мы также писали `return` несколько раз.

3. Одинаковые имена у функций

Эта часть называется перегрузка функций.

Вы действительно можете давать одинаковые имена вашим функциям

```c++
void f(int x) {
    std::cout << "int\n";
}

void f(double x) {
    std::cout << "double\n";
}

int main() {
    int a = 5;
    double b = 0.1;
    f(a);
    f(b);
}
```

Вывод:

```
int
double
```

На самом деле, функция определяется не именем, а именем + её аргументами, а именно их типами.

В примере написано 2 функции, `f(int)` и `f(double)`, а не одна.

Тогда как выбирается функция, которую вызвать?

Сначала, естественно, смотрится имя функции, которую вы написали.

А после этого смотрится, какие типы аргументов вы передали, и исходя из этого подбирается нужная версия функции.

В примере, вы оба раза вызываете функцию `f`, но первый раз передаете `a`, который `int`. Во второй раз вы передаете `b`, который `double`. Поэтому в первый раз вызвалась `f(int)`, а во второй -- `f(double)`. Порядок вызовов можно посмотреть в поле `Вывод`.

Еще пример:

```c++
int myMax(int x, int y) {
    return x > y ? x : y;
}

double myMax(double x, double y) {
    return x > y ? x : y;
}

long long myMax(long long x, long long y) {
    return x > y ? x : y;
}

char myMax(char x, char y) {
    return x > y ? x : y;
}
```

Эта функция возвращает максимум из двух данных чисел. В качестве агрументов вы можете передавать переменные любых типов, которые написаны в функциях.

Но что произойдет, если вы передаете в функцию переменную такого типа, которого нет в аргументах функции, т.е.:

```c++
void f(int x) {

}

int main() {
    double a = 0.3;
    f(a);
}
```

Правильно, в таком примере произойдет приведение типов. `double` будет кастоваться в `int`

Всё не так очевидно, если у `f` есть несколько версий. Например:

```c++
void f(int x) {
    std::cout << "int";
}

void f(long long x) {
    std::cout << "long long";
}

int main() {
    double a = 0.3;
    f(a);
}
```

Такая программа не скопилируется, просто потому что компилятор не знает, какую версию функциии выбрать. Ему одинаково плохо переводить `double` что в `int`, что в `long long`. Поэтому он предпочитает не выбирать и просто не компилировать такой код.

Даже такой пример не скомпилируется:

```c++
void f(int x) {
    std::cout << "int";
}

void f(long long x) {
    std::cout << "long long";
}

void f(float x) {
    std::cout << "long long";
}

int main() {
    double a = 0.3;
    f(a);
}
```

Все 3 варианта компилятор расценивает как одинаково плохие.

Подведем итог, как выбирается функция `f`

Все реализации функции сортируются компилятором по тому, насколько хорошо они подходят. После этого берется лучший вариант. Но если таких вариантов несколько, то происходит ошибка `ambigious call`, это `CE`


