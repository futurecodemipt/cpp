1.4 Циклы. Динамическое выделение памяти. Массивы. Многомерные массивы
=============

1. 3 цикла: `for`, `while`, `do while`
2. Бесконечные циклы
3. `continue` и `break`
4. Вложенные циклы, кол-во итераций в таких циклах
5. `continue` и `break` во вложенных циклах
6. Выделение памяти с помощью оператора `new`. Оператор `delete`
7. Массивы, многомерные массивы
8. Выделение памяти под массив `new[]`. Оператор `delete[]`
9. `std::vector`

# Циклы
Давайте рассмотрим такую задачу, программе на вход подаются числа, но вы не знаете их количество. Когда вам ввели число `x`, вы должны вывести число `2 * x`. Но если на вход пришло число 0, вы должны завершить работу программы. Тк кол-во чисел заранее не известно, до запуска мы не знаем точно, сколько чисел выводить. Проблему помогут решить циклы.

В C++ выделяют 3 типа циклов: `while`, `for`, `do while`.

__`while`__:

```c++
while (Условие) {
    тело цикла
}
```
Код внутри while будет выполнятся снова и снова, сверху вниз. Каждый раз доходя до конца тела цикла, будет проверка `верно ли` `Условие` внутри `while`, и, если оно верно, код внутри цикла начнет исполняться еще раз.

Посмотрим на такой пример:
```c++
int n = 1;
std::cout << "before while\n";
while (n <= 3) {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    n += 1;
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
}
std::cout << "after while\n";
```
Вывод будет
```
before while
start of cycle
n in the start 1
n in the end 2
end of cycle

start of cycle
n in the start 2
n in the end 3
end of cycle

start of cycle
n in the start 3
n in the end 4
end of cycle

after while
```

Как видно из вывода, пока `n` было <= 3, цикл начинал исполнятся заново. Но когда `n` стал равен `4`, еще раз в тело `while` мы не вошли.

---

Напишем решение той самой задачи из начала:
```c++
int x;
std::cin >> x;
while (x != 0) {
    std::cout << 2 * x << "\n";
    std::cin >> x;
}
```

Можно случайно написать `бесконечный` цикл: 
```c++
std::cout << "before while\n";
while (true) {
}
std::cout << "after while\n"; // Этого никогда не будет
```
Эта программа так и будет крутиться в цикле без конца, такие ситуации лучше не допускать.

---

_Задача1_:

Вводится число `n`. Нужно вывести все числа от `1` до `n`

Решение:
```c++
int n;
std::cin >> n;
int i = 1;
while (i <= n) {
    std::cout << i << "\n";
    ++i;
}

```
`i` пробежит все числа от `1` до `n`, а на `n+1` условие в `while` станет ложным, и цикл завершится.
Также, эту задачу можно решить намного лаконичней, а именно с помощью `for`. Давайте сделаем это

__`for`__:

Когда вы пишите `for`, вы должны ответить на 3 вопроса
1. Что нужно сделать до цикла: как правило, объявление переменных, но в целом любое выражение.
2. Какое условие продолжения цикла.
3. Что нужно сделать после очередной итерации `for`.

Если вы на них ответили, то можно написать такую конструкцию, её общий вид:

```c++
for (Что нужно сделать до цикла; Условие; Что нужно сделать после очередной итерации) {
    Тело цикла
}
```
По правилам, нужно обособлять выражения в круглых скобках с помощью `;`

---

Давайте теперь перепишем _Задачу1_

```c++
int n;
std::cin >> n;
int i = 1; // Это нужно сделать до цикла
while (i <= n) {
    std::cout << i << "\n";
    ++i; // Это нужно сделать после каждой итерации цикла
}
```

Код можно переписать как раз с помощью `for`:

```c++
int n;
std::cin >> n;
for (int i = 1; i <= n; ++i) {
    std::cout << i << "\n";
}
```

_Эти 2 реализации с `while` и c `for` эквивалентны._ Поэтому, когда вы видите написанный `for`, вы можете воспринимать его по аналогии с `while`

---
Посмотрите пример с последовательностью выводов. Заметьте, что `n` увеличивается только после завершения очередной итерации цикла:


```c++
std::cout << "before for\n";
for (int n = 1; n <= 3; ++n) {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
}
std::cout << "after for\n";
```
Вывод
```
before for
start of cycle
n in the start 1
n in the end 1
end of cycle

start of cycle
n in the start 2
n in the end 2
end of cycle

start of cycle
n in the start 3
n in the end 3
end of cycle

after for
```

---
Рассмотрим несколько примеров

_Пример1_
```c++
int n;
std::cin >> n;
for (int i = 0; i < n; i += 3) {
    std::cout << i << "\n";
}
```
Вывод при `n = 7`
```
0
3
6
```
---
_Пример2_

Здесь мы перебираем степени двойки и выводим их.

Также пример о том, что можно объявлять сразу несколько переменных(`int i = 0, step = 1`), и после очередной итерации цикла выполнять сразу несколько действий(`++i, step *= 2`)
```c++
for (int i = 0, step = 1; step <= 1024; ++i, step *= 2) {
    std::cout << i << " : " << step << "\n";
}
```
Вывод:
```
0 : 1
1 : 2
2 : 4
3 : 8
4 : 16
5 : 32
6 : 64
7 : 128
8 : 256
9 : 512
10 : 1024
```
---
Необязательно заполнять все места в круглых скобках `for`
```c++
int n;
std::cin >> n;
int i = 1;
for (; i <= n; ++i) {
    std::cout << i << "\n";
}
```
```c++
int n;
std::cin >> n;
for (int i = 1; i <= n;) {
    std::cout << i << "\n";
    ++i;
}
```

Можно писать и так, но тогда это никак не отличается от обычного `while`:
```c++
int n;
std::cin >> n;
int i = 1;
for (; i <= n;) { // while (i <= n)
    std::cout << i << "\n";
    ++i;
}
```

И даже так:

```c++
for (;;) { // бесконечный цикл
}
```
Это был пример бесконечного `for`


__`do while`__:

Используется довольно редко. Смысл в том, что сначала выполняется тело цикла, а только потом делается проверка условия продолжения, в то время как `while` и `for` сначала проверяют условие и только потом выполняют код внутри цикла.

```c++
int n = 1;
std::cout << "before do while\n";
do {
    std::cout << "start of cycle\n";
    std::cout << "n in the start " << n << "\n";
    /*
       Тут любые ваши инструкции
    */
    n += 1;
    std::cout << "n in the end " << n << "\n";
    std::cout << "end of cycle\n";
    std::cout << "\n";
} while (n <= 3);
std::cout << "after do while\n";
```
Вывод:
```
before do while
start of cycle
n in the start 1
n in the end 2
end of cycle

start of cycle
n in the start 2
n in the end 3
end of cycle

start of cycle
n in the start 3
n in the end 4
end of cycle

after do while

```
---


__`continue` и `break`__:

Иногда вам хочется прерывать итерацию цикла еще до её завершения. 

--- 

`break`:

```c++
int n = 6;
std::cout << "before for\n";
for (int i = 1; i <= n; ++i) {
	std::cout << "start, i = " << i << "\n";
    if (i == 4) {
        break;
    }
    std::cout << "end\n";
}
std::cout << "after for\n";
```
Вывод:
```
before for
start, i = 1
end
start, i = 2
end
start, i = 3
end
start, i = 4
after for
```
Есть ключевое слово `break`. Его можно писать только в теле цикла. Если программа дойдет до него, то она сразу же целиком выйдет из цикла и продолжит уже выполнять код после цикла. Заметьте, что после строчки `start, i = 4` мы сразу вышли из цикла и дошли до с строчки `after for`.

---

`continue`:

continue работает чуть иначе, см пример:
```c++
int n = 6;
std::cout << "before for\n";
for (int i = 1; i <= n; ++i) {
	std::cout << "start, i = " << i << "\n";
    if (i == 4) {
        continue;
    }
    std::cout << "end\n";
}
std::cout << "after for\n";
```
Вывод:
```
before for
start, i = 1
end
start, i = 2
end
start, i = 3
end
start, i = 4
start, i = 5
end
start, i = 6
end
after for
```
А именно, когда программа доходит до него, она также прерывает итерацию цикла, но не выходит из него полностью, как `break`, а начинает выполнять следующию итерацию.
Поэтому после строчки `start, i = 4` сразу идет `start, i = 5`.

---

__`Вложенные циклы`__:

Внутри тела цикла вы вполне себе можете писать еще один цикл.

---

Пример: Давайте выведем таблицу умножения

```c++
for (int i = 1; i <= 10; ++i) {
    for (int j = 1; j <= 10; ++j) {
        std::cout << i * j << " ";
    }
    std::cout << "\n";
}
```
Вывод
```
1 2 3 4 5 6 7 8 9 10 
2 4 6 8 10 12 14 16 18 20 
3 6 9 12 15 18 21 24 27 30 
4 8 12 16 20 24 28 32 36 40 
5 10 15 20 25 30 35 40 45 50 
6 12 18 24 30 36 42 48 54 60 
7 14 21 28 35 42 49 56 63 70 
8 16 24 32 40 48 56 64 72 80 
9 18 27 36 45 54 63 72 81 90 
10 20 30 40 50 60 70 80 90 100 
```
---

Также никогда не забывайте, что много вложенных циклов могут долго работать, например
```c++
for (int i = 1; i <= 100; ++i) {
    for (int j = 1; j <= 100; ++j) {
        for (int k = 1; k <= 100; ++k) {
            std::cout << i * j * k << " ";
        }
    }
}
```
Каждый цикл перебирает числа от 1 до 100, но тк они вложены, всего на экран будет выведено 1000000 чисел.

---

`continue` и `break` во вложенных циклах выполняют ту же роль. Только помните, что их действие будет распространяться ровно на тот цикл, где они написаны. Если их цикл оказался вложен в какой-то второй цикл, то второй останется нетронутым


```c++
std::cout << "before\n";
for (int i = 1; i <= 3; ++i) {
    std::cout << "big start, i = " << i << "\n";
    for (int j = 1; j <= 3; ++j) {
        std::cout << "small start, j = " << j << "\n";
        if (j >= 2) {
            break;
        }
        std::cout << "small end\n";
    }
    std::cout << "big end\n";
}
std::cout << "after\n";
```
Вывод:
```
before
big start, i = 1
small start, j = 1
small end
small start, j = 2
big end
big start, i = 2
small start, j = 1
small end
small start, j = 2
big end
big start, i = 3
small start, j = 1
small end
small start, j = 2
big end
after
```
Внешний цикл полностью пробежал все свои итерации, в то время как внутренний на `j = 2` постоянно обрывался

# Динамическое выделение памяти

Все ваши данные в программе должны где-то храниться. До этого все переменные, что вы создавали, хранились в месте, которое называется `стек`. У него ограниченный размер, и его как раз и используют для локальных переменных. Еще есть область памяти, которая называется `heap(куча)`. По сути, это ваша оперативная память. Так вот она явно больше чем стек, и там очень часто аллоцируют данные большого размера

Для работы с кучей используют операторы `new` и `delete`
__`new` и `delete`__:

```c++
int* ptrx = new int; // Просим выделить память под переменую int
std::cout << ptrx << "\n";

double* ptry = new double(3.14); // Просим выделить память под переменую double, сразу приравниваем к 3.14
std::cout << ptry << "\n";
std::cout << *ptry << "\n";

delete ptrx; // Освобождаем запрошенную память
delete ptry;
```
Вывод
```
0x55fe5950eeb0
0x55fe5950f2e0
3.14
```

`new` возвращает указатель на память, где хранится ваша переменная. Можно сразу приравнять ей какое-то значение. Хорошей практикой является отдавать память, когда она вам больше не нужна. Для этого есть `delete`. После него пишите адрес, который вам когда-то вернул `new`. Освобождать память по какому-то адресу можно только один раз, дважды писать `delete` с одним и тем же указателем нельзя.

Также, помните, что `new` и `delete` -- дорогие операции они работают достаточно долго.



# Массивы
Представьте, что вам на вход подается 100 чисел, и вам нужно их всех где-то хранить.
Отдельно под каждое число создать переменную не получится(можно, но никто же так не будет делать). Для таких целей в С++ есть массивы

Массив в С++, это несколько подряд идущих данных одного типа, например `int`.
Синтаксис такой:
```c++
int arr[5]; // Создали массив на 5 переменных
arr[0] = 1; // Индексация идет с 0
arr[1] = 2; // Чтобы обратиться к переменной, используют []
arr[2] = 4; // 3 число
arr[3] = 8; // 4 число
arr[4] = 16;// 5 число
for (int i = 0; i < 5; ++i) {
    std::cout << arr[i] << " ";
}
```
Вывод
```
1 2 4 8 16
```
В начале пишут тип данных, затем имя массива, в квадратных скобках кол-во переменных. Чтобы получить саму переменную, используют []. Отметим, что переменные в массиве хранятся, начиная с `0`. Т.е. первая переменная хранится в индексе `0`, вторая -- в индексе `1`, третья -- в индексе `2` и так далее.

Если вы не инициализируете индексы массива, то там может храниться мусорное значение, в общем также, как и с обычными переменными.

```c++
int arr[] = {1, 2, 3, 4}; // можно размер не указывать, если писать так
int n;
std::cin >> n;
int badArray[n]; // Никогда так не пишите.
```
Размер можно не писать, если пользоваться таким синтаксисом. Также, размер массива должен быть фиксирован, т.е. это либо число, либо переменная константа. Пример `badArray` как раз про это.

Такие массивы создатся на стеке.

Но можно создать и в оперативке:

Для этого используют `new[]`
```c++
int* arr = new int[5]; // Создали массив на 5 переменных
arr[0] = 1; // Индексация идет с 0
arr[1] = 2; // Чтобы обратиться к переменной, используют []
arr[2] = 4; // 3 число
arr[3] = 8; // 4 число
arr[4] = 16;// 5 число
for (int i = 0; i < 5; ++i) {
    std::cout << arr[i] << " ";
}
delete[] arr;
```
На самом деле код отличается только в том, как мы создаем массив. Дальше вы с ним работаете, как с обычным массивом. Только теперь он создан в оперативной памяти, а не на стеке. Как и раньше, хороший тон -- освободить память, но с массивами это делает `delete[]`

Также теперь уже можно создавать массивы с длиной не константа:

_Задача_:
Вводится число `n`. Затем `n` чисел. Нужно вывести эти числа в обратном порядке.
```c++
int n;
std::cin >> n;
int* goodArray = new int[n];
for (int i = 0; i < n; ++i) {
    std::cin >> goodArray[i];
}
for (int i = n - 1; i >= 0; --i) {
    std::cout << goodArray[i] << " ";
}
delete[] arr
```
Ввод:
```
5
1 2 4 8 16
```
Вывод:
```
16 8 4 2 1
```

__`std::vector`__:

Обычные массивы с трудом могут изменять свой размер. Простым способом это не сделать. Но есть `std::vector`
Синтаксис такой, пока просто запомните его:
```
std::vector<Тип данных> имя(размер)
```
Можете считать его аналогом массива, тогда предыдущая задача перепишется так:
```c++
int n;
std::cin >> n;
std::vector<int> goodArray(n);
for (int i = 0; i < n; ++i) {
    std::cin >> goodArray[i];
}
for (int i = n - 1; i >= 0; --i) {
    std::cout << goodArray[i] << " ";
}
```

При этом, чтобы его использовать, в начале кода нужно написать `#include <vector>`

Также, такой массив умеет менять свой размер, умеет добавлять элементы в начало, конец, и в целом на любую позицию. Для этого тоже есть особый синтаксис:
```c++
#include <iostream>
#include <vector>

int main() {
    int n = 2;
    std::vector<int> arr(n);
    arr[0] = 1;
    arr[1] = 2;

    std::cout << "array is:\n";
    int size = arr.size();
    std::cout << size << "\n"; // 2
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n\n";

    arr.push_back(4); // Добавить 4 в конец

    std::cout << "array is:\n";
    std::cout << arr.size() << "\n"; // 3
    for (int i = 0; i < arr.size(); ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << "\n\n";
}
```
Вывод:
```
array is:
2
1 2 

array is:
3
1 2 4 

```
Поясняем код:

После имени вектора мы пишем точку, а затем название действия, которые мы хотим над ним выполнить

1. имя.size() -- возвращает число, текущий размер массива
2. имя.push_back(число) -- добавляет элемент(который в круглых скобках) в конец массива
3. имя.resize(число) -- меняет размер массива на указанный в круглых скобках

