1.3 Приведение типов. Указатели и ссылки. Оператор запятая. Приоритет операций
=============

# Приведение типов
1. Рассказать, как приводятся типы в тех или иных ситуациях (операторы +, *, (?:))
2. Рассказать про касты вверх и вниз

У всех выражений в языке `C++` компилятор вычисляет тип, т.е. он известен еще на этапе компиляции.


Некоторые типы можно приводить(кастовать) к другим, например `int` -> `long long` или `char` -> `double`.

Мы неявно уже делали это с типом `bool` когда писали условия в `if`

В языке `C` был один способ явного приведения типов, а именно следующий:

```
Тип1 x;
Тип2 y = (Тип 1) x;
```

Таким способом мы сами задаем, какой тип хотим видеть. Но иногда компилятор делает это за нас.

Например:

Оператор `+` складывает 2 числа только одного типа, при этом в коде мы умеем складывать числа разных типов. Это возможно, тк компилятор приведет все слагаемые к максимальному типу, который среди них встречается.

```c++
#include <iostream>

int main() {
    std::cout << 'a' + 1;
}
```

Какой тип у `'a' + 1`. У `'a'` -- char, у `1` -- `int`, значит `a` будет преобразовано в `int` и только после этого будет сложение.
Поэтому код выведет `98`. Это пример каста вверх по иерархии типов.

```c++
#include <iostream>

int main() {
    char x = 'a';
    char y = x + 1;
    std::cout << y << "\n";
    std::cout << 'a' + 1 << "\n";
}
```
В этом случае у `x + 1` тип по прежнему `int`, но мы записываем результат в переменную `char`. Будет каст вниз по иерархии типов.
Поэтому в первой строчке будет выведено `b`, во второй `98`

```c++
#include <iostream>

int main() {
    std::cout << (char)('a' + 1) << "\n";
}
```
Здесь явно сказали компилятору кастовать к `char`, поэтому будет `b`

Также стоит отметить, что каст вверх по иерархии типов обычно происходит сначала в `int`, и если необходимо потом уже дальше по иерархии, т.е.

```c++
#include <iostream>

int main() {
    std::cout << typeid('a' + true).name();
}
```
Выведет `i`. (Это значит `int`);

В целом, можно показывать детям результат кастов с помощью `typeid`. Им необязательно пока знать, как он работает, но показать можно.

Рассмотрим еще один пример, где полезно делать приведение типов:

-----

_Задача_:

Дано 3 числа, a, b и mod. a < 10^9, b < 10^9, mod < 10^9

Вывести (a * b) % mod

_Решение_:

Заметим, что все 3 числа, а также результат помещаются в `int`

Кто-то может написать такой код:

```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (a * b) % mod;
    std::cout << res;
}
```
К сожалению, такой код приведет к ошибке, тк произведение `a * b` < 10 ^ 18, т.е. в `int` может не поместиться, будет переполение(UB). Конечно, можно все `int` заменить на `long long`

```c++
#include <iostream>

int main() {
    long long a, b, mod;
    std::cin >> a >> b >> mod;
    long long res = (a * b) % mod;
    std::cout << res;
}
```
Это будет работать, но представьте, что таких случаев в программе много. Использвать `long long` в 2 раза хуже по памяти, чем `int`, давайте перепишем.

```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = ((long long)a * b) % mod;
    std::cout << res;
}
```

Теперь `a` скастуется в `long long`, тогда и `b` скастуется в `long long`, такой же тип будет и у произведения. Тк к результату мы применяем модуль, то оно поместится в `int` и ошибок не будет.

Также можно написать:
```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (1ll * a * b) % mod;
    std::cout << res;
}
```
`1ll` - литерал, единица в типе `long long`

`1ull` - в типе `unsigned long long`


-----

Сейчас такой способ называют `C-style-cast` и в промышленном программировании стараются не использовать(но, конечно, не всегда)

В `C++` есть 4 варианта каста:
1. static_cast<`Тип`>(`выражение`)
2. reinterpret_cast<`Тип`>(`выражение`)
3. dynamic_cast<`Тип`>(`выражение`)
4. const_cast<`Тип`>(`выражение`)

+можно использовать старый добрый `C-style-cast`

Варианты 2-4 пока рассказывать рано, но 2 будет показан в методичке чуть позже.

Скорее всего, все примеры кастов, которые могут предложить школьники, это по сути `static_cast`

```c++
#include <iostream>

int main() {
    std::cout << static_cast<char>('a' + 1) << "\n";
}
```
```c++
#include <iostream>

int main() {
    int a, b, mod;
    std::cin >> a >> b >> mod;
    int res = (static_cast<long long>(a) * b) % mod;
    std::cout << res;
}
```

Формально `static_cast` говорит сделать преобразование типа еще на этапе компиляции, поэтому и называется `static`



Тернарный оператор:

`x = condition ? expr1 : expr2`

Какой тип у `x`? Максимальный из двух типов выражений, если они в целом совместимы.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    std::cout << (n > 0 ? 5.5 : 3) / 2;
}
```

У выражения `(n > 0 ? 5.5 : 3)` тип всегда `double`, поэтому деление на 2 будет работать корректно. Проверить можно, подставив `n = 0`



# Указатели и ссылки


_Ключевая тема, уделить ей особенное внимание._

__Указатели__

Каждая переменная, которую вы создаете(кроме возможно некоторых констант), лежит в оперативной памяти. А значит, у нее есть адрес. Почти на всех современных компьютерах этот адрес записывается 64 битам, т.е. 8 байтами. Для адреса в памяти существуют отдельные типы, которые хранят этот самый адрес.

Если переменная `x` имеет тип `Type`, то её адрес можно хранить в переменной типа `Type*`. Такие переменные называют указателями.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int; // В этой переменной можно хранить адрес любого int
    double* ptr_double; // В этой переменной можно хранить адрес любого double
    char* ptr_for_symbol; 
    std::cout << sizeof(ptr_int); // Будет 8
}
```
Как получить адрес переменной? Для это есть унарный оператор `&`
```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
}
```

Как вывести адрес? С этим справится обычный `cout`. Только нужно помнить, что он выводит адреса в 16-ричном формате.

```c++
#include <iostream>

int main() {
    int x = 0;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
}
```
_Уточнение_: Если попытаетесь так вывести адрес переменной типа `char`, то адрес вы не увидите. Это связано с тем что тип `char*` используется немного в другом контексте, а именно для C-style строк.

А если у вас есть адрес переменной, то как получить то, что под ним лежит, т.е. саму переменную?

Для этого есть унарный оператор `*`, который применяют к указателю(говорят, что указатель разыменовывают)


```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    std::cout << ptr_int << "\n";
    std::cout << *ptr_int << "\n"; // Выведет 15
    x += 1;
    std::cout << *ptr_int << "\n"; // Выведет 16
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_double << "\n";
    std::cout << *ptr_double << "\n"; // выведет 3.14
    y = 0;
    std::cout << *ptr_double << "\n"; // выведет 0
}
```

Применяя `*` к указателю вы получаете ту переменную, на которую он ссылается, поэтому в частности можно делать так:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr = &x;
    *ptr = 2; // Все равно что написать x = 2
    std::cout << x; // Будет 2
}
```
Базовые операции с указателем:
1. унарный *
2. +- число
3. - указатель

1 уже был рассмотрен, далее 2 и 3:


```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
}
```
Вы получите 3 строчки адресов, но можно заметить, что все они идут через 4 в 16-ричном формате. Это связано с тем, что размер `int` - 4 байта, и эти переменные идут в памяти подряд. Поэтому можно делать так:

```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    std::cout << &x << "\n" << &y << " " << &z << "\n";
    std::cout << &z - &y << "\n"; // 1
    std::cout << &z - &x << "\n"; // 2
    std::cout << &y - &x << "\n"; // 1
}
```
Еще один факт, указатели на тип размера `k` байт обязательно принимают значения адресов кратных `k`. Например, адреса `int` кратны 4.


Как видно `ptr1 - ptr2` это расстояние между указателями, но не в байтах. А в кол-ве переменных, которые между ними лежат.

Т.е. `ptr1 - ptr2` = `Расстояние в байтах` / `Рамер типа в байтах`

Отсюда понятно, как работает `ptr +- число`
```c++
#include <iostream>

int main() {
    int x = 15;
    int y = 3;
    int z = 100;
    int* ptr = &z;
    std::cout << ptr << "\n"; // Адрес z
    std::cout << *ptr << "\n"; // 100
    std::cout << ptr - 1 << "\n"; // Адрес y
    std::cout << *(ptr - 1) << "\n"; // 3
    std::cout << ptr - 2 << "\n"; // Адрес x
    std::cout << *(ptr - 2) << "\n"; // 15
}
```

Также писать `ptr1 - ptr2` можно только для указателей одного типа:
```c++
#include <iostream>

int main() {
    int x = 15;
    int* ptr_int = &x;
    double y = 3.14;
    double* ptr_double = &y;
    std::cout << ptr_int - ptr_double << "\n"; // Тут CE
}
```

Тип `void*`

Как видно, независимо от типа указатель это адрес в памяти. Все указатели 64 - битны. Что если разработчик просто хочет хранить адрес без привязки к типу?

Для это есть `void*`
Но с ним несколько нюансов

```c++
#include <iostream>

int main() {
    int x = 15;
    void* ptr = &x; // В ptr лежит адрес x
    std::cout << ptr << "\n"; // Можно вывести адрес
    std::cout << ptr + 1 << "\n"; // Можно и так, но компилятор будет ругаться
    std::cout << *ptr << "\n"; // Так нельзя, void не содержит информацию о типе
    int* ptr_x = ptr; // Так тоже нельзя
}
```
Как мы уже обсудили, указатели разных типов несовместимы друг с другом. Вы можете преобразовывать указатель к `void*`. Но все остальные касты уже запрещены. 

Т.е. `void*` -> `int*`, `long long*` -> `double*` и т.п. Всё это уже писать нельзя, будет CE.

Но если очень хочется, то можно использовать `reinterpret_cast`, он как раз создан для таких случаев.

```c++
#include <iostream>

int main() {
    double x = 3.14;
    double* ptr = &x;
    long long* p = reinterpret_cast<long long*>(ptr);
    std::cout << *p;
}
```
Теперь `p` указывает на ту же область памяти, что и `ptr`. Но `p` считает, что там лежит `long long`, но на самом то деле там `double`. Поэтому разименовывая его мы получим число типа `long long`, с такими же битами, что и у числа `x`. Конечно, ничего хорошего от такого не стоит ожидать, но иногда это полезно.

Также стоит отметить следующее. Указатели это обычные переменные веса 8 байт. Значит, они лежат в памяти, как переменные. А значит, можно создать указатель на эту область памяти.
```c++
#include <iostream>

int main() {
    long long x = 3;
    long long* ptr = &x;
    long long** ptr_of_ptr = &ptr;
    std::cout << ptr << "\n " << ptr_of_ptr << "\n";
}
```
Указатель, это число в 16-ричном формате. Как получить само это число? Мы знаем, что оно весит 64 бита, причем беззнаковое. Т.е. это число типа unsigned long long.
Такой код адрес переводит в число:

```c++
#include <iostream>

int main() {
    int x = 5;
    void* ptr = &x;
    unsigned long long res = *reinterpret_cast<unsigned long long*>(&ptr);
    std::cout << ptr << "\n" << res << "\n";
}
```

Убедиться, что адреса типов размера k, действительно кратны k.


-------

__Ссылки__

Рассказать про обычные и немного про константные ссылки.

На начальном уровне детям можно объяснить, что ссылка на переменную `x`, это та же переменная `x`, только с другим именем. В будущих уроках будет показано, что это не совсем так.
```c++
#include <iostream>

int main() {
    int x = 5;
    int& y = x; // y -- ссылка на x
    std::cout << x << " " << y; // 5 5
    x += 1;
    std::cout << x << " " << y; // 6 6
    y += 1;
    std::cout << x << " " << y; // 7 7
}
```
Теперь `x` и `y` для нас одно и то же.

```c++
#include <iostream>

int main() {
    int x = 5;
    int& y; // CE, так нельзя, ссылка должна ссылаться на что-то
    int& z = 5; // CE, так тоже нельзя, ссылка должна ссылаться на переменную
}
```

Константные ссылки
```c++
#include <iostream>

int main() {
    int x = 5;
    const int& z; // CE, так нельзя, константная ссылка должна ссылаться на что-то
    const int& y = 6; // А вот так уже можно
    std::cout << y << "\n";
    const int& t = x;
    std::cout << x << " " << t << "\n";
    x += 1; // Так можно
    std::cout << x << " " << t << "\n";
    t += 1; // Так нельзя, ведь t - КОНСТАНТНАЯ ссылка
    std::cout << x << " " << t << "\n";
}
```

Стоит отметить, что сама ссылка, как объект, весит 8 байт.

# Оператор запятая

Рассказать, что есть такой оператор, и что его результат, это последнее выражение после запятой.
```c++
#include <iostream>

int main() {
    int x;
    double y;
    char z;
    x = 5, y = 2.5, z = 'a'; // Можно писать выражения через запятую
    // Но запятая это оператор, и у него есть возвращаемое значение
    bool f = (true, false);
    std::cout << f << "\n"; // Выведет 0
    std::cout << (x + 6, y + 1.1); // Выведет 3.6
}
```

# Приоритет операций

Частично приоритет операций уже рассматривался на прошлом занятии. Достаточно просто упомянуть про новые операторы, что мы изучили.

А также обсудить, почему работают подобные примеры:
```c++
#include <iostream>

int main() {
    int x = 5;
    int y = 0;
    std::cout << x << " " << y << "\n"; // 5 0
    y = ++x;
    std::cout << x << " " << y << "\n"; // 6 6
    y = x++;
    std::cout << x << " " << y << "\n"; // 7 6
}
```

```c++
#include <iostream>

int main() {
    int x = 5;
    int y = 3;
    std::cout << x << " " << y << "\n"; // 5 3
    y = y + (x += 6);
    std::cout << x << " " << y << "\n"; // 11 14
}
```

# Ввод и вывод данных

Ученики уже сталкивались с этой темой, здесь лишь еще несколько фактов.

```c++
#include <iostream>

int main() {
    int x;
    double y;
    char z;
    std::cin >> x >> y >> z; // Можно ввожить сразу несколько переменных.
    int t;
    if (std::cin >> t) { // cin  возвращает bool, его можно писать в условиях
        return 0;
    }
    std::cout << x << y << z; // Можно выводить сразу несколько
    std::cout << "\n"; // Символ переноса строки
    std::cout << std::endl; // Метка сброса буфера вывода
}
```
Отдельно про `'\n'` и `std::endl`. 

`std::cout` не сразу выводит то, что его попросили, он это делает по мере заполнения, а потом уже выводит большими кусками. Это называется буфер вывода. Так вот `std::endl` заставляет его сбросить буфер вывода, т.е. вывести все содержимое + ставит `\n` на конец.

Поэтому если нет явной необходимости, то писать `std::endl` крайне НЕ РЕКОМЕНДУЕТСЯ. Такой вариант работает в разы дольше.
