1.5 Рекурсия. Пространства имен
=============

# Рекурсия

Когда вы пишите функции, вы можете в теле функции вызывать эту же функцию. Такие ситуции называют рекурсией:
```c++
int f(int x) {
    f(x);
}
```
Каждый раз, `f` будет вызываться заново. В данном примере, это будет происходит бесконечно, т.е. ваша программа зациклится. Но на самом деле, прямо бесконечно она работать не будет. Это связано с тем, что вызывая функцию, на стек кладятся её адрес, он весит `8 байт`, а как мы помним, у стека не очень большой размер. Поэтому рано или поздно, стек у вас переполнится, и будет ошибка `stack overflow`. Это `runtime error` (RE). Кстати, так называется один очень известный сайт для программистов, рано или поздно вы с ним точно столкнетесь)

Поэтому, если возникла неободимость писать рекурсию, первое, о чем вы должны подумать, это как недопустить бесконечную рекурсию.

Рассмотрим задачу.

_Задача1_:

Числа Фибонначи, это последовательность 1, 1, 2, 3, 5, 8, 11...

Каждое следующее число, это сумма двух предыдущих.

Формально

1. $F_1$ = 1
2. $F_2$ = 1
3. $F_n$ = $F_{n-1}$ + $F_{N - 2}$, при $n > 2$

Дано число $n$. Вывести $F_n$

_Решение_:

Здесь нам и пригодится рекурсия:

Посмотрим на функцию:

```c++
int fibo(int n) {
    return fibo(n - 1) + fibo(n - 2);
}
```

Это почти правильная функция, но в ней нет условий остановки рекурсии, она по-прежнему бесконечная

```c++
int fibo(int n) {
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    return fibo(n - 1) + fibo(n - 2);
}
```

Теперь условия остановки есть, функция будет работать

_Код_:
```c++
for (int i = 1; i <= 10; ++i) {
    std::cout << "F" << i << " = " << fibo(i) << "\n";
}
```

_Вывод_:
```
F1 = 1
F2 = 1
F3 = 2
F4 = 3
F5 = 5
F6 = 8
F7 = 13
F8 = 21
F9 = 34
F10 = 55
```

Заметим, что если написать `fibo(0)`, то мы снова получим бесконечную рекурсию, тк такие ситуации у нас не обрабатваются. Поэтому тут вы либо предполагаете, что у вас не вызывают функцию от аргументов $n < 1$, либо добавляете это в точки остановки.

В целом, старайтесь избегать рекурсию, тк она медленнее, чем аналогичная программа без неё. Хотя, конечно, есть задачи, в которых без рекурсии не справиться.


Давайте еще немного посмотрим на задачу про числа Фибонначи. Мы слишком часто вызваем фукнцию `fibo` от аргументов, от которых она уже вызывалась. Давайте посчитаем кол-во вызовов следующим кодом:

```c++
#include <iostream>

int total = 0;

int fibo(int n) {
    ++total;

    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    return fibo(n - 1) + fibo(n - 2);
}

int main() {
    fibo(20);
    std::cout << total << "\n";
}
```

_Вывод_:
```
13529
```

Для $n = 20$ потребовалось 13529 вызовов! Хотя потенциально, нам достаточно посчитать ответ всего лишь для $F_1$, $F_2$, $F_3$, ..., $F_{19}$, $F_{20}$. Т.е. 20 различных вызовов.

Давайте оптимизировать программу. Метод называется `мемоизация`. Смысл в том, что вы запоминаете значения, которые посчитала ваша функция для определенных $n$. И если она снова будет вызвана от этих аргументов, то она не будет честно их считать, а просто посмотрит на сохраненное значение.

Для этого давайте воспользуемся грязным трюком и глобально создадим вектор, в котором будем хранить ответы

```c++
#include <iostream>
#include <vector>

int total = 0;
std::vector<int> ans;

int fibo(int n) {
    ++total;
    if (ans[n] != 0) {
        return ans[n];
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    int res = fibo(n - 1) + fibo(n - 2);
    ans[n] = res;
    return res;
}

int main() {
    int n = 20;
    ans.resize(n + 1);
    
    fibo(20);
    std::cout << total << "\n";
}
```

_Вывод_:
```
37
```

Получилось 37 вызовов, а не 13529. Достаточно приятно.

В начале кода функции стоит

```c++
if (ans[n] != 0) {
    return ans[n];
}
```

Если функция уже вызывалась от данного $n$ то, в `ans[n]` хранится ответ на дынный вызов. Но если нет, то в конце кода мы пишем

```c++
int res = fibo(n - 1) + fibo(n - 2);
ans[n] = res;
```

Таким образом мы запоминаем ответ на запрос.

Давайте немного перепишем код. Чтобы вектор не был глобальным, и $n$ вводилось с клавиатуры

```c++
#include <iostream>
#include <vector>

int fibo(int n, std::vector<int>& ans) {
    if (ans[n] != 0) {
        return ans[n];
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    int res = fibo(n - 1, ans) + fibo(n - 2, ans);
    ans[n] = res;
    return res;
}

int main() {
    int n;
    std::cin >> n;
    std::vector<int> ans(n + 1);
    int res = fibo(n, ans);
    std::cout << res << "\n";
}
```

Тут мы вектор передаем как аргумент, и __очень важно__ передавать его именно по ссылке, а не просто так. Так мы гарантируем, что вектор в рамках вызовов остается одним и тем же, а не создается заново для каждого вызова отдельно.



# Пространства имен


Помните проблему с перегрузкой функций? Представьте, что вы пишите огромную библиотеку с кодом, и там вы объявляете функции с разными именами. Если кто-нибудь захочет пользоваться вашей библиотекой, то ему придется контроллировать, что он не называет свои собственные функции так же, как и вы называли у себя в коде. Эту проблему помогают решить пространства имен:

_Пример1a_:

```c++
namespace MyNameSpace {
    int square(int x) {
        return x * x;
    }

    bool notNull(int x) {
        return x;
    }
}
```
Можно объявлять свои собственные пространства имен таким образом. Теперь, чтобы вызвать функцию от туда, вам нужно написать перед функцией `MyNameSpace::`. Если этого не сделать, будет `ошибка компиляции` (CE). 

```c++
int main() {
    MyNameSpace::square(5);  // Вернет 25
    MyNameSpace::notNull(1); // Вернет true
    square(5);  // Эта строчка не скомпилируется
    notNull(1); // Эта строчка не скомпилируется
}
```

При этом, вне пространтсва имен мы можем создать функции с тем же именем

_Пример2a_:

```c++
#include <iostream>

namespace MyNameSpace {
    void square(int x) {
        std::cout << "square in namespace\n";
    }

    void notNull(int x) {
        std::cout << "notNull in namespace\n";
    }
};

void square(int x) {
    std::cout << "global square\n";
}

void notNull(int x) {
    std::cout << "global notNull\n";
}

int main() {
    MyNameSpace::square(5);  // square in namespace
    MyNameSpace::notNull(1); // notNull in namespace
    square(5);  // global square
    notNull(1); // global notNull
}
```

Можно создавать несколько пространств имен в одном коде, их можно делать вложенными. Главное, что нужно понять, если функция лежит в пространстве имен `name`, то доступ к ней происходит через `name::`. К слову, в англоязычной литературе оператор `::` называют `scope resolution`, а его использование в пространствах имен -- `name lookup`. 

Есть возможнось не писать постоянно `::`. Для этого достаточно написать `using namespace MyNameSpace`


_Пример1б_:

```c++
namespace MyNameSpace {
    int square(int x) {
        return x * x;
    }

    bool notNull(int x) {
        return x;
    }
}

using namespace MyNameSpace;

int main() {
    MyNameSpace::square(5);  // Вернет 25
    MyNameSpace::notNull(1); // Вернет true
    square(5);  // Вернет 25
    notNull(1); // Вернет true;
}
```

В промышленной разработке крайне не рекомендуется писать `using namespace`. Как раз из-за проблемы, описанной в начале этого пункта.
К слову, если написать так:

_Пример2б_:
```c++
#include <iostream>

namespace MyNameSpace {
    void square(int x) {
        std::cout << "square in namespace\n";
    }

    void notNull(int x) {
        std::cout << "notNull in namespace\n";
    }
};

void square(int x) {
    std::cout << "global square\n";
}

void notNull(int x) {
    std::cout << "global notNull\n";
}

using namespace MyNameSpace;

int main() {
    MyNameSpace::square(5);  // square in namespace
    MyNameSpace::notNull(1); // notNull in namespace
    square(5);  // CE
    notNull(1); // CE
}
```

Как раз и произойдет эта ошибка. Первые 2 вызовы не приведут к CE, но последние 2 -- приведут. Компилятор не знает, какую фукнцию выбрать, `ambigious call`

Теперь понятно, что значит популярная строчка
 
```c++
using namespace std;
```

Множество стандартных фукнций лежит именно в `std`
