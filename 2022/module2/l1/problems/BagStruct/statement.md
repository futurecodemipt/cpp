У вас есть несколько мешков в которых хранятся монеты, у каждого своя вместимость. И тут вы решили пересыпать монеты из одних мешков в другие. Когда из одного мешка вы высыпаете монеты в другой, вы делаете это до упора, а именно, либо пока не высыпете все монеты из первого, либо пока во втором не останется места. Формально, пусть из мешка $A$ вы пытаетесь пересыпать монеты в мешок $B$. В мешке $A$ было $N_a$ монет, в мешке $B$ -- $N_b$ монет. Также пусть вместимость мешка $B$ -- $c$ монет. Тогда после того, как вы пересыпете монеты, в мешке $B$ будет на $delta = min(c, N_b + N_a) - N_b$ монет больше, а в мешке $A$ будет на $delta$ монет меньше.


Напишите структуру BagStruct, которая представляет собой мешок.

У нее будет конструктор от 1 целого аргумента -- вместимость мешка. Помните, что в мешке никогда не может быть больше монет, чем его вместимость

Метод Mint(unsigned int number), который пытается положить в мешок $number$ монет. 

Метод Balance(), который возвращает текущее кол-во монет в мешке

Также метод Transfer, который будет перекладывать монеты из текущего мешка, в указанный в аргументах мешок. У этого метода будет 2 варианта:

Transfer(BagStruct&) и Transfer(BagStruct*). Т.е. второй мешок можно передать как по ссылке, так и по указателю.

Таким образом ваша структура будет иметь вид:

```c++

struct BagStruct {
    BagStruct(unsigned int capacity);
    void Mint(unsigned int number);
    unsigned int Balance();
    void Transfer(BagStruct& destination);
    void Transfer(BagStruct* destination);
};

```

Реализуйте эту структуру. Можете написать новые поля или методы при необходимости.


Пример использования:

```c++
BagStruct b1(100);
b1.Mint(90);

BagStruct b2(100);
b2.Mint(90);

b1.Transfer(b2);

assert(b1.Balance() == 80);
assert(b2.Balance() == 100);

```

В систему отправляйте только код самой структуры.
