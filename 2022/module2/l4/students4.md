std::list и std::deque
=====

# Понятие ассимптотики

Время работы алгоритмов нужно уметь как-то оценивать. Считать время или кол-во тактов процессора не всегда правильно. Поэтому используют такое _понятие_, как _ассимптотика_.

Мы рассмотрим его поверхностно

Рассмотрим 2 цикла:

```c++
const int N1 = 5;
for (int i = 0; i < N1; ++i) {
    std::cout << i << "\n";
}
```

и 

```c++
int N2;
std::cin >> N2;
for (int i = 0; i < N2; ++i) {
    std::cout << i << "\n";
}
```

Сколько работают первый и второй циклы? Первый -- всегда примерно одно и то же время, однако второй работает тем дольше, чем больше переменная $N2$. Причем если переменная $N2$ станет в 2 раза больше, то и цикл будет в ~2 раза дольше работать. Говорят, линейное от $N2$ время работы и обозначают $O(N2)$. Первый же цикл работает за линейное от 1 время (5 = 5 * 1), поэтому пишут $O(1)$.

Итак, когда пишут, что алгоритм/метод работает за $O(1)$, имеют ввиду, что на его выполнение тратится какое-то количество действий, но это количество можно ограничить сверху некой константой. (Т.е. работает не больше, чем несколько действий)

Когда пишут, что алгоритм/метод работает за $O(N)$, имеют ввиду, что на его выполнение тратится какое-то количество действий, и это количество пропорционально переменной $N$.

# list

`#include <list>`


Вектор позволял хранить элементы последовательно. Причем, добавлять новые за $O(1)$ мы могли только в конец вектора. При этом также за $O(1)$ был доступ к любому элементу по индексу. Добавлять элементы в начало можно за $O(n)$.

`std::list` позволяет добавлять элементы как в конец, так и в начало за $O(1)$. Также можно и удалять как с конца, так и из начала за $O(1)$. За это мы платим тем, что не можем больше обращаться к элементу по индексу, и в целом, доступ к произвольному элементу осуществляется за $O(n)$, с некоторой оговоркой.


Синтаксис:

```c++
std::list<Тип> myList;
std::list<Тип> myListWithElements({5, 6, 7, 101});
```

Методы:

1. `push_back(x)` -- добавит элемент в конец листа
2. `push_front(x)` -- добавит элемент в налало листа
3. `pop_back()` -- удалит последний элемент
4. `pop_front()` -- удалит первый элемент
5. `size()` -- текущий размер
6. `begin()` -- итератор на первый элемент
7. `end()` -- итератор на конец листа(элемент после последнего)
8. `front()` -- первый элемент
9. `back()` -- последний элемент
10. `insert(iter, x)` -- вставит элемемент по итератору
11. `erase(iter)` -- удалит элемент по итератору

Все перечисленные методы работают за $O(1)$.

При этом, как видно из методов, мы не можем пока перебирать элементы так, как делали это раньше. Тут нам помогут итераторы. А именно:

```c++
std::list<Тип>::iterator iter = lst.begin();
```
В начале получаем итератор на первый элемент. Затем с помощью него можно перебрать все элементы в листе.

Итераторы std::list умеют намного меньше, чем итераторы std::vector

1. `++iter`  -- можно
2. `--iter`  -- можно
3. `iter++`  -- можно
4. `iter--`  -- можно
5. `iter +- k`  -- нельзя
6. `k +- iter`  -- нельзя
7. `iter1 - iter2`  -- нельзя
8. `iter[index]` -- нельзя

Поэтому, в частности, чтобы получить элемент с индексом `index`, нужно написать что-то в таком духе:

```c++
template<typename T>
T& AtIndex(std::list<T>& myList, unsigned int index) {
    auto iter = myList.begin();
    for (unsigned int i = 0; i < index; ++i) {
        ++iter;
    }
    return *iter;
}
```

Поэтому в общем получение `index`-ого элемента происходит за $O(n - index)$. Пишут обычно $O(n)$, т.к. `index` может быть любым.

В то же время, если уже есть итератор на `index`-ый элемент, то можно произвести вставку/удаление на позиции `index`:

```c++
template<typeaname T>
std::list<T>::iterator IterAtIndex(const std::list<T>& myList, unsigned int index) {
    auto iter = myList.begin();
    for (unsigned int i = 0; i < index; ++i) {
        ++iter;
    }
    return iter;
}
```

```c++
int main() {
// ...
    unsigned int index;
    std::cin >> index;
    int value;
    std::cin >> value;
    auto iter = IterAtIndex(myList, index);
    myList.insert(iter, value);
}
```

```c++
int main() {
// ...
    unsigned int index;
    std::cin >> index;
    auto iter = IterAtIndex(myList, index);
    myList.erase(iter);
}
```

В этих примерах мы вызываем функцию, которая возвращает итератор за $O(n)$, но именно вставка/удаление происходит за $O(1)$.

--------

Как `std::list` устроен внутри, и почему на него накладываются такие ограничения.

Мы не будем рассматривать полную реализацию, но опишем, как примерно она выглядит. 

Представьте следующую ситуацию, $n$ людей стоят в ряд, все смотрят в одну сторону. Каждый из них знает только своего соседа спереди и сзади. Также каждый их них хранит некий элемент(как раз таки элемент на позиции). Еще иногда приходят новые люди, которые хотели бы встать либо в начало очереди (`push_front`), либо в конец (`push_back`). Поэтому вам необходимо хранить соответственно первого и последнего человека(если они вообще есть), чтобы поставить нового человека на нужное место. Это можно было бы описать такой структурой:

```c++
struct Node {
    Node* prev;
    Node* next;
    int value;
};
```
Где `prev` хранит указатель на соседа сзади, а `next` -- на соседа спереди.

`Node` как раз и олицетворяет человека из примера. Также нужно создать `Node` на фиктивный элемент, чтобы производить вставку в начало и конец.

В самом начале у вас пустой лист, поэтому есть только 2 объекта `Node` -- фиктивный первый и фиктивный последний.

Проинициализировать можно так, 0 означает, что такого элемента нет:

```c++

Node* FakeFirst = new Node;
Node* FakeLast = new Node;

FakeFirst->prev = 0;
FakeFirst->next = FakeLast;
FakeLast->prev = FakeFirst;
FakeLast->next = 0;
```

_Примечание_: `оператор ->` это упрощение следующего кода:

```c++
(*FakeFirst).next = FakeLast; // Можно писать так
FakeFirst->next = FakeLast; // То же самое
```

Т.е. `->` сначала применяет `*` к объекту, а затем обращается к методу.

Напишем `push_front`:

```c++
void PushFront(int x) {
    Node* newNode = new Node;
    newNode->value = x;
    Node* currentFirst = FakeFirst->next;
    FakeFirst->next = newNode;
    newNode->prev = FakeFirst;
    newNode->next = currentFirst;
    currentFirst->prev = newNode;
}
```

и `push_back`:

```c++
void PushBack(int x) {
    Node* newNode = new Node;
    newNode->value = x;
    Node* currentLast = FakeLast->prev;
    FakeLast->prev = newNode;
    newNode->next = FakeLast;
    newNode->prev = currentLast;
    currentLast->next = newNode;
}
```

Упакуем все это в отдельный класс:

```c++
class List {
    struct Node {
        Node* prev;
        Node* next;
        int value;
    };

    unsigned int size = 0;
    Node* FakeFirst;
    Node* FakeLast;
public:

    List() {
        FakeFirst = new Node;
        FakeLast = new Node;
        FakeFirst->prev = 0;
        FakeFirst->next = FakeLast;
        FakeLast->prev = FakeFirst;
        FakeLast->next = 0;
    }
    
    void PushFront(int x) {
        Node* newNode = new Node;
        newNode->value = x;
        Node* currentFirst = FakeFirst->next;
        FakeFirst->next = newNode;
        newNode->prev = FakeFirst;
        newNode->next = currentFirst;
        currentFirst->prev = newNode;
        ++size;
    }

    void PushBack(int x) {
        Node* newNode = new Node;
        newNode->value = x;
        Node* currentLast = FakeLast->prev;
        FakeLast->prev = newNode;
        newNode->next = FakeLast;
        newNode->prev = currentLast;
        currentLast->next = newNode;
        ++size;
    }

    unsigned int Size() const {
        return size;
    }

    int& AtIndex(unsigned int index) {
        auto currentNode = FakeFirst;
        for (unsigned int i = 0; i <= index; ++i) {
            currentNode = currentNode->next;
        }
        return currentNode->value;
    }

    int& Front() {
        return FakeFirst->next->value;
    }

    int& Back() {
        return FakeLast->prev->value;
    }
};
```

_Эта реализация не претендует быть корректной технически, т.к. мы никак не удаляем созданные вершины, не обрабатываем некоторые ошибки, не реализовали итераторы и т.п. Однако с точки зрения алгоритма, приблизительно в таком виде и реализован `std::list`. Более того, можно обойтись одной фиктивной вершиной, а не двумя._


# deque

`#include <deque>`

Представьте контейнер, который хранит элементы последовательно, умеет вставлять как в начало, так и в конец за $O(1)$, более того получать произвольный элемент также за $O(1)$. Получится `std::deque`.

Синтаксис:

```c++
std::deque<Тип> myDeque;
std::deque<Тип> myDequeWithElements({5, 6, 7, 101});
```

Методы:

1. `push_back(x)` -- добавит элемент в конец листа
2. `push_front(x)` -- добавит элемент в налало листа
3. `pop_back()` -- удалит последний элемент
4. `pop_front()` -- удалит первый элемент
5. `size()` -- текущий размер
6. `begin()` -- итератор на первый элемент
7. `end()` -- итератор на конец листа(элемент после последнего)
8. `front()` -- первый элемент
9. `back()` -- последний элемент
10. `operator[index]` -- вернет `index`-ый элемент

Все эти методы работают за $O(1)$.

Также есть:

11. `insert(iter, x)` -- вставит по итератору
12. `erase(iter)` -- удалит по итератору

Эти методы работают за линейное время от $min(x, n - x)$.

У `deque` также есть и итераторы, они умеют делать почти то же, что и в векторе:

1. `++iter`  -- можно
2. `--iter`  -- можно
3. `iter++`  -- можно
4. `iter--`  -- можно
5. `iter +- k`  -- можно
6. `k +- iter`  -- можно
7. `iter1 - iter2`  -- можно
8. `iter[index]` -- можно

Внимательный читатель заметит, что пока `deque` умеет все, что и вектор, при этом справляется с вставкой в начало за $O(1)$, в то время как вектору нужно $O(n)$ на это. На самом деле за такие возможности `deque` платит эффективностью. А именно, `operator[]` у вектора работает быстрее, чем у `deque`. Также у вектора элементы лежат последовательно, поэтому можно работать как с итераторами, так и с указателями на элементы. У `deque` это не так.

Пример работы и вывода:

```c++
std::deque<int> dq;

dq.push_back(5);
dq.push_front(4);
dq.push_front(2);

for (unsigned int i = 0; i < dq.size(); ++i) {
    std::cout << dq[i] << " ";
}
std::cout << "\n";

dq.push_front(1);

for (auto it = dq.begin(); it != dq.end(); ++it) {
    std::cout << *it << " ";
}
std::cout << "\n";

dq.insert(dq.begin() + 2, 3);

auto iter = dq.begin();
for (unsigned int i = 0; i < dq.size(); ++i) {
    std::cout << iter[i] << " ";
}
std::cout << "\n";
```

Вывод:

```
2 4 5 
1 2 4 5 
1 2 3 4 5 
```

# range-based for loop

Не все контейнеры позволяют обращаться к элементам по индексу, например `std::list`. К тому же иногда нужно просто перебрать сами элементы, и не очень хочется создавать для этого отдельные объекты под итераторы или индексы. `range-based for` позволяет делать это напрямую.

Посмотрите на цикл с итераторами

```c++
for (auto iter = container.begin(); iter != container.end(); ++iter) {
    auto value = *iter;
    // Действия с value, например вывод на экран
}
```

`range-based for` это особый вид цикла `for`. Он позволяет не писать подобную логику с итераторами.

У него свой синтаксис, в общем виде его можно записать так:

```c++
for (auto value : container) {
    // Действия с value, например вывод на экран
}
```

`value` с каждой новой итерацией цикла будет принимать значение очередного элемента вашего контейнера.

-------

Посмотрите примеры:

```c++
std::vector<int> myVector({1, 2, 3, 4, 5});
for (auto x : myVector) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

-------


```c++
std::list<int> myList({1, 2, 3, 4, 5});
for (auto x : myList) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------

```c++
std::list<int> myDeque({1, 2, 3, 4, 5});
for (auto x : myDeque) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------


Работает даже с массивами константной длины:

```c++
int myArray[] = {1, 2, 3, 4, 5};
for (auto x : myArray) {
    std::cout << x << " ";
}
```

Вывод:

```
1 2 3 4 5
```

------

Пара уточнений

Вместо `auto` можно писать тип, который хранится в контейнере или массиве. В примерах выше -- это `int`.

Также, если просто писать `auto`, то мы получим копии на элементы контейнера, а не сами элементы. Если нужны сами объекты, нужно просто использовать ссылочный тип `auto&`

```c++
std::vector<int> myVector({1, 2, 3, 4, 5});

for (auto x : myVector) {
    x *= 2; // Не меняет реальные элементы вектора
}

for (auto x : myVector) {
    std::cout << x << " ";
}
std::cout << "\n";

for (auto& x : myVector) {
    x *= 2; // Меняет реальные элементы вектора
}

for (auto x : myVector) {
    std::cout << x << " ";
}
std::cout << "\n";
```

Вывод:

```
1 2 3 4 5 
2 4 6 8 10
```

# stack и queue

`stack` это контейнер, который хранит элементы последовательно, и позволяет за $O(1)$ вставлять в конец, удалять последний, получать доступ к последнему элементу. 

`queue` это контейнер, который хранит элементы последовательно, и позволяет за $O(1)$ вставлять в конец, удалять первый, получать доступ к первому элементу.

Запомнить можно так:

`queue` переводится как `очередь`. Когда люди встают в очередь, они встают именно в её конец. Когда человек выходит из очереди, он выходит именно из её начала. `FIFO` -- _first in first out_.

`stack` можно представить как стопку тарелок, которые необходимо помыть. Вы моете посуду и обычно берете тарели все-таки сверху. И когда кладут новые тарелки, их тоже обычно ставят наверх. `FILO` -- _first in last out_.

Теперь перейдем непосредственно к `stack` и `queue` в С++.

Как вы могли заметить, все, что требуется от этих двух структур, уже умеет замечательный контейнер `deque`. Разработчики языка тоже это заметили, поэтому стандартные `stack` и `queue` используют внутри себя `deque`. Причем используют его довольно конкретно, он передается в качестве шаблонного параметра:

```c++
template<class T, class Container = std::deque<T>>
class stack;
```

и 

```c++

template<class T, class Container = std::deque<T>>
class queue;
```

`deque` указан, как шаблонный параметр по умолчанию, поэтому его можно не писать при объявлении класса. Однако вы можете передать и свой собственный класс, главное, чтобы он соответствовал требованиям `stack` и/или `queue`.

Ровно по этой причине стандартные `stack` и `queue` по времени работают столько же, сколько и `deque`. Поэтому его можно использовать вместо этих двух без потери эффективности. 

Рассмотрим все же их детально:


----


# stack

`#include <stack>`

Синтаксис:

```c++
std::stack<Тип> myStack;
std::stack<Тип> myStackWithElements({5, 6, 7, 101});
```

Методы:

1. `push(x)` -- то же, что и `push_back(x)`
2. `pop()` -- то же, что и `pop_back()`
3. `top()` -- то же, что и `back()`
4. `size()` -- размер

У стека нет итераторов. Его используют только в тех задачах, в которых его функционала достаточно.

Также, из-за того что стандартный `stack` основан на `deque`, иногда вместо `stack` используют `vector`. Действительно, `vector` умеет делать всё, что требует `stack`. Да и работает он быстрее, чем `deque`.


# queue

`#include <queue>`

Синтаксис:

```c++
std::queue<Тип> myQueue;
std::queue<Тип> myQueueWithElements({5, 6, 7, 101});
```

Методы:

1. `push(x)` -- то же, что и `push_back(x)`
2. `pop()` -- то же, что и `pop_front()`
3. `front()` -- первый элемент
4. `back()` -- последний элемент
5. `size()` -- размер

У очереди нет итераторов. Её используют только в тех задачах, в которых её функционала достаточно.

---

Итого было рассмотрено 5 контейнеров. 

`std::vector`, `std::list`, `std::deque`, `std::stack` и `std::queue`. Выбирайте контейнер исходя из того, что требует та или иная задача.

Все эти контейнеры хранят элементы последовательно. Разница в том, что именно мы требуем от контейнера. Чем больше требования, тем сложнее или дольше он будет работать.