В векторе иногда нужно перевыделять память. В этой задаче вы напишите функцию, которая это делает. А именно, напишите

```c++
template<typename T>
T* IncreaseSize(T*& buffer, unsigned int oldSize, unsigned int newSize);
```

buffer -- указатель на память размера oldSize. Вас просят вернуть указатель на память размера newSize. Конечно, все элементы старого буффера должны попасть и в новый. 

Пример:

```c++
int* buffer = new int[3];
buffer[0] = 1;
buffer[1] = 2;
buffer[2] = 3;
IncreaseSize(buffer, 3, 6);
buffer[3] = 4;
buffer[4] = 5;
buffer[5] = 6;
for (int i = 0; i < 6; ++i) {
    std::cout << buffer[i] << " ";
}
delete[] buffer;
// Должен вывести:
// 1 2 3 4 5 6
```

Гарантируется, что oldSize <= newSize.

Что касается памяти, IncreaseSize должен работать так, чтобы после его вызова переданный buffer нужно было по-прежнему удалять через delete[]. Более того, не должно возникнуть ситуации, что какая-то выделенная память осталась неудаленной. (memory leak)

В систему отправляйте только код функции.