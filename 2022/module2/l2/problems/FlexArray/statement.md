В этой задаче вам предстоит написать структуру, которая будет работать одновременно как обычный массив в С++, и как list в Python

А именно, напишите структуру

```c++

template<typename T>
struct FlexArray;

```

Т.е. это шаблонная структура. Она представляет собой массив элементов типа T фиксированной длины, причем длина передается в конструкторе. По умолчанию нужно считать, что длина 0. (Это не обязывает вас пользоваться лишь классическими массивами при реализации)


Доступ к элементам происходит через метод `at(unsigned int index)` -- возвращает `index`-ый элемент массива. Корректно напишите этот метод как для неконстантных, так и для константных структур. А именно, вызов at(i) у константых структур не должен позволить изменить содержимое массива, и более того, не может стоять слева от знака =

Метод Size(), который возвращает текущий размер массива.

А теперь самое интересное.

Напишите operator+ от двух FlexArray и operator+=, где сложение FlexArray считается как конкатенкация их элементов. Т.е. {1, 3, 5} + {2, 4} = {1, 3, 5, 2, 4}.

Складывать два разных FlexArray можно только если их шаблонные аргументы совпадают.

operator += должен эффективно прибавлять в текущему FlexArray новый массив.

Также напишите operator* и operator*= от FlexArray и числа $k > 0$, где умножение на число k -- конкатенация самого себя k раз. Т.е. {1, 2} * 3 = {1, 2, 1, 2, 1, 2}. Можно считать, что k -- unsigned long

Умножать нужно уметь как слева направо, так и справа налево. Т.е. возможно всего 3 варианта FlexArray *= k, FlexArray * k, k * FlexArray



```c++

int main() {
    FlexArray<int> flex(3);
    flex.at(0) = 1;
    flex.at(1) = 2;
    flex.at(2) = 3;
    std::cout << flex.Size(); // 3

    auto prod = flex * 2;

    for (int i = 0; i < prod.Size(); ++i) {
        std::cout << prod.at(i) << " ";
    }
    std::cout << "\n";
    // Должен вывести 1 2 3 1 2 3

    FlexArray<int> last(2);
    last.at(0) = 4;
    last.at(1) = 5;
    flex += last;

    for (int i = 0; i < flex.Size(); ++i) {
        std::cout << flex.at(i) << " ";
    }
    std::cout << "\n";
    // Должен вывести 1 2 3 4 5

}

```


Итого, от вас реализация этих методов, возвращаемые типы специально здесь не написаны:

```c++

FlexArray<T>::FlexArray();
FlexArray<T>::FlexArray(size_t);
FlexArray<T>::at(size_t);
FlexArray<T>::Size();
FlexArray<T>::operator += (const FlexArray&);
FlexArray<T>::operator *= (size_t);
operator+(const FlexArray<T>&, const FlexArray<T>&);
operator*(const FlexArray<T>&, size_t);
operator*(size_t, const FlexArray<T>&);

```

В систему отправляйте только код структуры + возможно необходимые # include